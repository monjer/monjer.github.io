<!doctype html>




<html class="theme-next muse" lang="zh-Hans">
<head>
  <meta charset="UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=edge" />
<meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1"/>






<meta http-equiv="Cache-Control" content="no-transform" />
<meta http-equiv="Cache-Control" content="no-siteapp" />















  
  
  <link href="/lib/fancybox/source/jquery.fancybox.css?v=2.1.5" rel="stylesheet" type="text/css" />




  
  
  
  

  
    
    
  

  

  

  

  

  
    
    
    <link href="//fonts.googleapis.com/css?family=Lato:300,300italic,400,400italic,700,700italic&subset=latin,latin-ext" rel="stylesheet" type="text/css">
  






<link href="/lib/font-awesome/css/font-awesome.min.css?v=4.6.2" rel="stylesheet" type="text/css" />

<link href="/css/main.css?v=5.1.1" rel="stylesheet" type="text/css" />


  <meta name="keywords" content="Hexo, NexT" />





  <link rel="alternate" href="/atom.xml" title="monjer's note" type="application/atom+xml" />




  <link rel="shortcut icon" type="image/x-icon" href="/favicon.ico?v=5.1.1" />






<meta property="og:type" content="website">
<meta property="og:title" content="monjer&#39;s note">
<meta property="og:url" content="http://monjer.github.io/index.html">
<meta property="og:site_name" content="monjer&#39;s note">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="monjer&#39;s note">



<script type="text/javascript" id="hexo.configurations">
  var NexT = window.NexT || {};
  var CONFIG = {
    root: '/',
    scheme: 'Muse',
    sidebar: {"position":"left","display":"post","offset":12,"offset_float":0,"b2t":false,"scrollpercent":false},
    fancybox: true,
    motion: false,
    duoshuo: {
      userId: '0',
      author: '博主'
    },
    algolia: {
      applicationID: '',
      apiKey: '',
      indexName: '',
      hits: {"per_page":10},
      labels: {"input_placeholder":"Search for Posts","hits_empty":"We didn't find any results for the search: ${query}","hits_stats":"${hits} results found in ${time} ms"}
    }
  };
</script>



  <link rel="canonical" href="http://monjer.github.io/"/>





  <title>monjer's note</title>
  <script async src="//pagead2.googlesyndication.com/pagead/js/adsbygoogle.js"></script>
<script>
  (adsbygoogle = window.adsbygoogle || []).push({
    google_ad_client: "ca-pub-5347284824666460",
    enable_page_level_ads: true
  });
</script>
</head>

<body itemscope itemtype="http://schema.org/WebPage" lang="zh-Hans">

  





  <script type="text/javascript">
    var _hmt = _hmt || [];
    (function() {
      var hm = document.createElement("script");
      hm.src = "https://hm.baidu.com/hm.js?2b4f08dbd457a5e207bff33f77b0eafc";
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(hm, s);
    })();
  </script>











  
  
    
  

  <div class="container sidebar-position-left 
   page-home 
 ">
    <div class="headband"></div>

    <header id="header" class="header" itemscope itemtype="http://schema.org/WPHeader">
      <div class="header-inner"><div class="site-brand-wrapper">
  <div class="site-meta ">
    

    <div class="custom-logo-site-title">
      <a href="/"  class="brand" rel="start">
        <span class="logo-line-before"><i></i></span>
        <span class="site-title">monjer's note</span>
        <span class="logo-line-after"><i></i></span>
      </a>
    </div>
      
        <p class="site-subtitle"></p>
      
  </div>

  <div class="site-nav-toggle">
    <button>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
      <span class="btn-bar"></span>
    </button>
  </div>
</div>

<nav class="site-nav">
  

  
    <ul id="menu" class="menu">
      
        
        <li class="menu-item menu-item-home">
          <a href="/" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-home"></i> <br />
            
            首页
          </a>
        </li>
      
        
        <li class="menu-item menu-item-archives">
          <a href="/archives" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-archive"></i> <br />
            
            归档
          </a>
        </li>
      
        
        <li class="menu-item menu-item-tags">
          <a href="/tags" rel="section">
            
              <i class="menu-item-icon fa fa-fw fa-tags"></i> <br />
            
            标签
          </a>
        </li>
      

      
    </ul>
  

  
</nav>



 </div>
    </header>

    <main id="main" class="main">
      <div class="main-inner">
        <div class="content-wrap">
          <div id="content" class="content">
            
  <section id="posts" class="posts-expand">
    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2017/08/03/CSS外边距折叠/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/08/03/CSS外边距折叠/" itemprop="url">CSS外边距折叠</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-08-03T23:11:37+08:00">
                2017-08-03
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在我们页面布局的时候，经常会出现的情况是在垂直方向上我们同时设置相邻的父子元素或兄弟元素之间的margin外边距，但最后的结果并不是按照我们想象中的叠加值，而是最终它们当中margin的最大值。这种情况在CSS的盒模型中被称作是 <em>外边距折叠</em>（margin collapsing）。我们通常会困惑于这种情况，即使通过各种设置，最后也不一定能达到我们最终的效果。下面是一些关于外边距折叠的一些总结。</p>
<h3 id="外边距折叠定义"><a href="#外边距折叠定义" class="headerlink" title="外边距折叠定义"></a>外边距折叠定义</h3><p>下面是W3C中关于margin collapsing的定义：</p>
<p><strong>在CSS中相邻的两个或者多个盒子之间的margin会组合成单个margin。这个组合的方式叫折叠（collapse），组合后的margin结果称作是折叠的margin。</strong></p>
<p>有几点需要注意的是：</p>
<ul>
<li>外边距堆叠只发生在相邻元素之间；</li>
<li>外边距折叠只发生在垂直方向上；</li>
</ul>
<p>两个margin相邻要满足：</p>
<ul>
<li>都必须是在普通文档流中；</li>
<li>都必须是在同一个块格式上下文中（block formatting contexts）;</li>
<li>它们中间不存在内联盒子，清除浮动，内边距（padding），边框；</li>
<li>两个盒子都是在垂直方向上相邻，包括以下几种情况：<ul>
<li>父元素的上外边距与其第一个子元素的上外边距</li>
<li>父元素的下外边距与最后一个子元素的下外边距</li>
<li>元素的下外边距与子下一个兄弟元素的上外边距</li>
<li>无法建立块级上下文的元素的上外边距和下外边距之间（min-height的计算值为0；height的计算值为0或auto；没有处于同一文档流的子元素）</li>
</ul>
</li>
</ul>
<p>其中不会发生margin collapsing的情况包括：</p>
<ul>
<li>水平方向上相邻元素不会发生外边距折叠；</li>
<li>文档根元素的margin不会折叠；</li>
<li>浮动元素与其它元素之间，包括浮动元素与其文档流中的子元素之间</li>
<li>建立新的块级别上下文的元素与其处于文档流的子元素之间</li>
<li>绝对定位的元素与其它元素，包括其文档流中的子元素之间</li>
<li>内联块元素之间，包括与其子元素之间</li>
<li>元素下外边距与清除浮动的相邻兄弟元素的上外边距之间</li>
<li>元素的上外边距与元素的第一个子元素的上外边距之间有上边框，上内边距，或者子元素已清除浮动</li>
<li>元素的下外边距与元素的最后一个子元素的下外边距之间有下边框，下内边距，或者子元素已清除浮动</li>
<li>空元素自己的上外边距和下外边距之间，如果元素的min-height属性不是0；有上或下边距；有上火下内边距；它的height是非0且非auto值；包含line box；只要满足一种情况</li>
</ul>
<h3 id="合并的计算规则"><a href="#合并的计算规则" class="headerlink" title="合并的计算规则"></a>合并的计算规则</h3><p>在外边距折叠后，计算规则如下：</p>
<ul>
<li>如果两个margin值都是正值，则取其中的最大值</li>
<li>如果一个正值一个负值，则取相加后的结果</li>
<li>如果两个都是负数，取最小的那个负数值</li>
</ul>
<h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><ul>
<li>父子关系</li>
</ul>
<script async src="//jsfiddle.net/onoh4rsx/embed/html,css,result/"></script>

<ul>
<li>相邻兄弟关系</li>
</ul>
<script async src="//jsfiddle.net/pvehz1mm/1/embed/html,css,result/"></script>

<ul>
<li>单个空元素</li>
</ul>
<script async src="//jsfiddle.net/j3f2y2n6/embed/html,css,result/"></script>

<h3 id="清除折叠"><a href="#清除折叠" class="headerlink" title="清除折叠"></a>清除折叠</h3><ul>
<li>父子关系</li>
</ul>
<script async src="//jsfiddle.net/LbLvL3zp/embed/html,css,result/"></script>

<ul>
<li>相邻兄弟</li>
</ul>
<script async src="//jsfiddle.net/fLqe09uu/embed/html,css,result/"></script>

<ul>
<li>单个空元素</li>
</ul>
<script async src="//jsfiddle.net/u566rush/embed/html,css,result/"></script>


<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://www.w3.org/TR/CSS2/box.html#collapsing-margins" target="_blank" rel="external">Collapsing margins</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/CSS/CSS_Box_Model/Mastering_margin_collapsing" target="_blank" rel="external">Mastering margin collapsing</a></li>
<li><a href="http://www.seifi.org/css/understanding-taming-collapsing-margins-in-css.html" target="_blank" rel="external">Understanding &amp; Taming Collapsing Margins in CSS</a></li>
<li><a href="https://stackoverflow.com/questions/19718634/how-to-disable-margin-collapsing" target="_blank" rel="external">How to disable margin-collapsing?</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2017/05/28/Sublime-Text3-sidebar折叠快捷键设置/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2017/05/28/Sublime-Text3-sidebar折叠快捷键设置/" itemprop="url">Sublime Text3 sidebar折叠快捷键设置</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2017-05-28T15:51:18+08:00">
                2017-05-28
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>打开Sublime Text，在左上角的菜单选线中，依次打开<code>Sublime Text</code>-&gt;<code>Preferences</code>-&gt;<code>Key Bindings</code>。</p>
<p>在用户设置的keymap中添加</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&#123; &quot;keys&quot;: [&quot;super+\\&quot;], &quot;command&quot;: &quot;toggle_side_bar&quot; &#125;,</div><div class="line">&#123; &quot;keys&quot;: [&quot;super+shift+r&quot;], &quot;command&quot;: &quot;reveal_in_side_bar&quot; &#125;</div></pre></td></tr></table></figure>
<p>其中<code>toggle_side_bar</code>用来设置折叠打开的快捷键;<code>reveal_in_side_bar</code>是用来定位当前文件在sidebar中的所在位置的快捷键。</p>
<p>以上设置是基于Mac下，Windows下可以将<code>super</code>键改为<code>Ctrl</code>或<code>Alt</code>键。</p>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/12/05/使用overflow属性清除浮动-译/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/05/使用overflow属性清除浮动-译/" itemprop="url">使用overflow属性清除浮动(译)</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-05T22:15:25+08:00">
                2016-12-05
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在编写基于浮动（float）布局的代码时，我们经常面对的问题之一是：包装容器（wrapper container）的高度没有延展至浮动子元素的高度。通常解决方法是在浮动元素后面添加清除浮动的元素，或者给包装容器添加一个clearfix。但难道你不知道使用overflow属性也可以解决这个问题？这也是一个新的CSS技巧。很早之前就有文章描述过这个技巧。现在我想要再次重温这个主题，顺便讲解几个技巧。</p>
<p><a href="http://webdesignerwall.com/demo/clear-float/" style="border: 1px solid #ccc;padding:4px 10px; display: inline-block;" target="_blank" rel="external">VIEW DEMO CLEAR FLOATS</a></p>
<h3 id="Demo1"><a href="#Demo1" class="headerlink" title="Demo1"></a>Demo1</h3><p>下面的代码实例展示了父容器没有展开至浮动子元素高度的问题。解决这个问题，只要向父容器添加<code>overflow:hidden</code>或<code>overflow:auto</code>属性。这可能是清除浮动最简单的方式。</p>
<img src="/2016/12/05/使用overflow属性清除浮动-译/demo-1.png" alt="demo1" title="demo1">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  overflow: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Demo2"><a href="#Demo2" class="headerlink" title="Demo2"></a>Demo2</h3><p><code>overflow:auto</code>也可以阻止其它内容环绕浮动元素。比如在设计一个评论列表。可能多数情况下头像居左，评论内容居右。为了阻止评论内容环绕头像，只要向评论内容所在容器添加<code>overflow:hidden</code>。这里使用overflow的好处是避免为评论内容的容器设置浮动或固定宽度。评论内容会自动在浮动头像后面对齐。</p>
<img src="/2016/12/05/使用overflow属性清除浮动-译/demo-2.png" alt="demo2" title="demo2">
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">.image &#123;</div><div class="line">  float: left;</div><div class="line">&#125;</div><div class="line"></div><div class="line">.text &#123;</div><div class="line">  overflow: hidden;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="弊端"><a href="#弊端" class="headerlink" title="弊端"></a>弊端</h3><p>虽然是一个清除浮动的好技巧，但也不是完美无缺的。</p>
<ul>
<li>使用<code>overflow:auto</code>，如果内容超出了容器的边界，会引起滚动条出现。比如，你有一个很长的文本（如很长的url文本）或一张大图，超出了容器的宽度，就会显示滚动条。</li>
<li>为了避免滚动条的出现，所以应该使用<code>overflow:hidden</code>。但这种方式也是有缺点的。使用overflow:hidden会隐藏所有超出容器边界的内容。</li>
</ul>
<h3 id="word-wrap"><a href="#word-wrap" class="headerlink" title="word-wrap"></a>word-wrap</h3><p>解决长文本问题的方法是，给容器添加<code>word-wrap: break-word;</code>，强制文本换行。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">.container &#123;</div><div class="line">  word-wrap: break-word;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="max-width"><a href="#max-width" class="headerlink" title="max-width"></a>max-width</h3><p>为了阻止图片超出容器边界，为其设置<code>max-width: 100%;</code>，图片会缩放以适应容器的宽度。</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">.container img &#123;</div><div class="line">  max-width: 100%;</div><div class="line">  height: auto;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p><a href="http://webdesignerwall.com/tutorials/css-clearing-floats-with-overflow" target="_blank" rel="external">原文链接</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://colinaarts.com/articles/the-magic-of-overflow-hidden/" target="_blank" rel="external">The magic of “overflow: hidden”</a></li>
<li><a href="https://css-tricks.com/all-about-floats/" target="_blank" rel="external">All About Floats</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/12/04/在Git中保留空目录/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/12/04/在Git中保留空目录/" itemprop="url">在Git中保留空目录</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-12-04T21:46:56+08:00">
                2016-12-04
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="为什么要保留空目录"><a href="#为什么要保留空目录" class="headerlink" title="为什么要保留空目录"></a>为什么要保留空目录</h3><p>构建一个工程的模板，需要保留必要的目录名称和目录结构，以便于后续根据目录名称来填写必要的文件，比如要创建一个简单的编写前台的目录:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line">public</div><div class="line">   |</div><div class="line">   + - styles</div><div class="line">   |</div><div class="line">   + - script</div><div class="line">   |    |</div><div class="line">   |    + - vendor</div><div class="line">   |    |</div><div class="line">   |    + - views</div><div class="line">   |    |</div><div class="line">   |    + - models</div><div class="line">   |    |</div><div class="line">   |    + - common</div><div class="line">   |    |</div><div class="line">   |    + - app.js</div><div class="line">   |</div><div class="line">   + - assets</div><div class="line">   |</div><div class="line">   + - index.html</div></pre></td></tr></table></figure>
<h3 id="Git中的默认设置"><a href="#Git中的默认设置" class="headerlink" title="Git中的默认设置"></a>Git中的默认设置</h3><p>Git默认情况下<a href="https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F" target="_blank" rel="external">不将空目录纳入版本管理中</a>，当提交目录中的文件时，目录会被自动提交到Git中。运行</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">git add &lt;directory&gt;</div></pre></td></tr></table></figure>
<p>会将目录下所有的文件提交到Git中。</p>
<h3 id="解决方法"><a href="#解决方法" class="headerlink" title="解决方法"></a>解决方法</h3><p>既然git不支持追踪空目录的功能，所以只能为所有必要的空目录创建文件占位符，大致有两种常用的比较好的形式：</p>
<ul>
<li>一种方式是在空目录下添加一个README.md文件，用以说明目录存在的作用。</li>
<li>另一种方式时创建一个名为.gitkeep的文件。</li>
</ul>
<p>例如:</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">$ touch styles/.gitkeep</div><div class="line">$ git add styles</div></pre></td></tr></table></figure>
<p>在正式将目录填满所需文件后可以删除空目录占位符文件。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://git.wiki.kernel.org/index.php/GitFaq#Can_I_add_empty_directories.3F" target="_blank" rel="external">Can I add empty directories?</a></li>
<li><a href="http://stackoverflow.com/questions/115983/how-can-i-add-an-empty-directory-to-a-git-repository" target="_blank" rel="external">How can I add an empty directory to a Git repository?</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/06/14/JavaScript-JSON对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/06/14/JavaScript-JSON对象/" itemprop="url">JavaScript JSON对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-06-14T22:13:17+08:00">
                2016-06-14
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>在jQuery中，<code>jQuery.parseJSON()</code>用来完成将字符串解析为JSON对象的操作，最近jQuery3.0版本的升级说明中该方法被标记为过时的接口，以后对JSON的解析和序列化，推荐使用原生的JSON对象，这是各大浏览器不断升级逐渐向标准靠拢的结果。在JavaScript中，JSON是一个用来对JSON进行解析或序列化的对象。它主要包含两个方法<code>JSON.parse()</code>和<code>JSON.stringify()</code>。</p>
<h3 id="JSON-parse"><a href="#JSON-parse" class="headerlink" title="JSON.parse"></a>JSON.parse</h3><p><code>JSON.parse()</code>，用来解析字符串生成JavaScript对象，它接收一个json格式的字符串，并返回一个对应的JavaScript对象。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'&#123; "name": "json string"&#125;'</span>;</div><div class="line"><span class="keyword">var</span> obj = <span class="built_in">JSON</span>.parse(str);</div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// Object &#123;name: "json string"&#125;</span></div></pre></td></tr></table></figure>
<p>如果传入json字符串的格式错误，这个方法会抛出异常，所以最好添加<code>try/catch</code>块。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">"&#123; 'name': 'json string'&#125;"</span>;</div><div class="line"><span class="keyword">var</span> obj ;</div><div class="line"><span class="keyword">try</span>&#123;</div><div class="line">  obj = <span class="built_in">JSON</span>.parse(str);</div><div class="line">&#125;<span class="keyword">catch</span>(err)&#123;</div><div class="line">  <span class="built_in">console</span>.log(err); <span class="comment">// SyntaxError: Unexpected token '</span></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(obj); <span class="comment">// undefined</span></div></pre></td></tr></table></figure>
<h3 id="JSON-stringify"><a href="#JSON-stringify" class="headerlink" title="JSON.stringify"></a>JSON.stringify</h3><p>与<code>JSON.parse()</code>方法的功能相反，<code>JSON.stringify()</code>方法接收一个JavaScript对象，并返回一个对应的json格式的字符串。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123; <span class="attr">name</span>: <span class="string">"json string"</span>&#125;;</div><div class="line"><span class="keyword">var</span> str = <span class="built_in">JSON</span>.stringify(obj);</div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> str); <span class="comment">// string</span></div><div class="line"><span class="built_in">console</span>.log(str); <span class="comment">// &#123;"name":"json string"&#125;</span></div></pre></td></tr></table></figure>
<h3 id="兼容性"><a href="#兼容性" class="headerlink" title="兼容性"></a>兼容性</h3><p>不管是桌面端还是移动端浏览器，所有主流浏览器都已经实现了原生的JSON对象，IE8以上版本的IE浏览器也实现了该对象。兼容性的说明参见<a href="http://caniuse.com/json" target="_blank" rel="external">JSON parsing</a></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="http://json.org/" target="_blank" rel="external">Introducing JSON</a></li>
<li><a href="https://github.com/jquery/jquery/issues/2800" target="_blank" rel="external">Deprecate jQuery.parseJSON</a></li>
<li><a href="https://github.com/jquery/jquery/blob/1.12-stable/src/ajax/parseJSON.js" target="_blank" rel="external">jQuery.parseJSON source code</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/05/30/ES6笔记-Modules/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/30/ES6笔记-Modules/" itemprop="url">ES6笔记 - Modules</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-30T21:48:45+08:00">
                2016-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>模块化开发提供一种机制能够将软件架构中的各部分代码按需独立开来，这有利于提高代码的重用性，可测试性，可读性，基本上所有主流的编程语言都会提供一种内置的机制来讲代码进行模块隔离。JavaScript中历来被诟病的就是缺少模块化的内置支持，所有定义的变量函数都一并暴露在全局作用域下，很容易造成命名冲突，一个文件包含所有代码的情况也降低了代码可读性。虽然CommonJS和AMD规范一定程度上分别解决了服务器端和浏览器端JavaScript代码模块化的需求，但并没有在语言层面上实现一种统一。ES6为了解决这些问题，在语言层面上提出了Module。</p>
<h3 id="模块的特性"><a href="#模块的特性" class="headerlink" title="模块的特性"></a>模块的特性</h3><p>ES6中的模块是存储在文件中的，一个文件对应一个模块，相比较传统的用script标签引入的js文件，模块有以下特性：</p>
<ul>
<li>模块下的代码自动运行在严格模式下。</li>
<li>在模块下新建的变量作用域是当前模块，而不会暴露在全局作用域下。</li>
<li>模块下<code>this</code>的值为undefined</li>
<li>模块可以导出（export）任何需要被其它外部模块引入的代码</li>
<li>模块可以从其它模块引入（import）任何必须的代码。</li>
</ul>
<h3 id="export语句-amp-import语句"><a href="#export语句-amp-import语句" class="headerlink" title="export语句 &amp; import语句"></a>export语句 &amp; import语句</h3><p>使用export语句可以将变量，函数，class导出去供其它模块引入。使用import语句可以导入其它模块导出的内容。</p>
<h4 id="基本的导出-导入"><a href="#基本的导出-导入" class="headerlink" title="基本的导出,导入"></a>基本的导出,导入</h4><p>如导出moduleA中的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleA.js</span></div><div class="line"><span class="comment">// 导出变量</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'black'</span> , <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="comment">// 导出函数</span></div><div class="line"><span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">printColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 导出类</span></div><div class="line"><span class="keyword">export</span> <span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>加入moduleB.js与moduleA.js在相同的目录，则在moduleB文件中导入moduleA文件导出的内容：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleB.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; colors &#125;<span class="keyword">from</span> <span class="string">'./moduleA'</span></div><div class="line"><span class="keyword">import</span> &#123; printColors &#125;<span class="keyword">from</span> <span class="string">'./moduleA'</span></div><div class="line"><span class="keyword">import</span> &#123; Person &#125;<span class="keyword">from</span> <span class="string">'./moduleA'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors);</div><div class="line">printColors();</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>以上import后面是需要引入的内容，from后面指定的被导入的模块的文件路径。虽然moduleA被import了多次，但moduleA.js只会运行一次，第一次导入后moduleA的会被缓存起来，再次导入的话，后面的import语句其实导入的是缓存的模块。</p>
<h4 id="export和import的限制"><a href="#export和import的限制" class="headerlink" title="export和import的限制"></a>export和import的限制</h4><p>export和import必须是在其它语句或函数的外部使用，否则会报语法错误，因为模块机制的引入为的是让JavaScript引起执行更加严格的静态检测，所有以下的语法都是错误的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleA.js</span></div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123; <span class="comment">// 错误</span></div><div class="line">  <span class="keyword">export</span> <span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'black'</span> , <span class="string">'blue'</span>];</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">export</span> <span class="function"><span class="keyword">function</span> <span class="title">exportFn</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 错误</span></div><div class="line">    <span class="comment">// todo</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">testFn();</div><div class="line"><span class="comment">// moduleB.js</span></div><div class="line"></div><div class="line"><span class="keyword">if</span>(<span class="literal">true</span>)&#123; <span class="comment">// 错误</span></div><div class="line">  <span class="keyword">import</span> &#123;colors&#125; <span class="keyword">from</span> <span class="string">'./moduleA'</span>;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>)</span>&#123; <span class="comment">// 错误</span></div><div class="line">  <span class="keyword">import</span> &#123;testFn&#125; <span class="keyword">from</span> <span class="string">'./moduleA'</span> ;</div><div class="line">&#125;</div><div class="line"></div><div class="line">testFn();</div></pre></td></tr></table></figure>
<h4 id="声明后一次导入或导出"><a href="#声明后一次导入或导出" class="headerlink" title="声明后一次导入或导出"></a>声明后一次导入或导出</h4><p>上一个例子中是在声明的时候同时导出，另一种更清晰的方式，是在所有声明或定义后再模块的最后导出需要导出的内容，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleA.js</span></div><div class="line"><span class="comment">// 导出变量</span></div><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'black'</span> , <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="comment">// 导出函数</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="comment">// 导出类</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">export</span> &#123;colors , printColors , Person&#125;; <span class="comment">// 一次导出</span></div></pre></td></tr></table></figure>
<p>同样可以在一个import语句按需导入模块的内容，如：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleB.js</span></div><div class="line"></div><div class="line"><span class="keyword">import</span> &#123; colors , printColors , Person&#125; <span class="keyword">from</span> <span class="string">'./moduleA'</span></div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(colors);</div><div class="line">printColors();</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<h4 id="export与import的重命名"><a href="#export与import的重命名" class="headerlink" title="export与import的重命名"></a>export与import的重命名</h4><p>默认情况下模块export导出变量，函数，类的名称就是模块import时引用的变量，函数类的名称，导入和导出的内容的名称是相互匹配的，
但export和import语句同时也支持重命名功能，这需要使用<code>as</code>关键字。</p>
<p>export重命名,如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleA.js</span></div><div class="line"></div><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'black'</span> , <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 对color进行重命名，其它名称类似</span></div><div class="line"><span class="keyword">export</span> &#123;colors <span class="keyword">as</span> COLORS , printColors , Person <span class="keyword">as</span> PersonClass&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// moduleB.js</span></div><div class="line"></div><div class="line"><span class="comment">// 使用新的名称</span></div><div class="line"><span class="keyword">import</span> &#123;COLORS , printColors , PersonClass&#125; <span class="keyword">from</span> <span class="string">'./moduleA'</span>;</div></pre></td></tr></table></figure>
<p>import重命名，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'black'</span> , <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="comment">// 对color进行重命名，其它名称类似</span></div><div class="line"><span class="keyword">export</span> &#123;colors  , printColors , Person&#125;;</div><div class="line"></div><div class="line"></div><div class="line"><span class="comment">// moduleB.js</span></div><div class="line"></div><div class="line"><span class="comment">// 使用新的名称</span></div><div class="line"><span class="keyword">import</span> &#123;</div><div class="line">  colors <span class="keyword">as</span> COLORS ,</div><div class="line">  printColors ,</div><div class="line">  Person <span class="keyword">as</span> PersonClass&#125; <span class="keyword">from</span> <span class="string">'./moduleA'</span>;</div></pre></td></tr></table></figure>
<p>以上export和import都使用<code>as</code>关键字分别对导出和引入的名称进行了重命名。</p>
<h4 id="export-default与import-default"><a href="#export-default与import-default" class="headerlink" title="export default与import default"></a>export default与import default</h4><p>以上的例子中都是显示的指定了导出内容的名称，此外ES6还支持导出模块的default值。所谓default值是指用<code>export default</code>语句导出的单一的变量，函数或类，它代表了模块的默认导出行为，每个模块只能有导出一个default值，同时用default导出多个值会报语法错误。</p>
<p>导出default值</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add.js</span></div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> <span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>引入默认值
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">import</span> add <span class="keyword">from</span> <span class="string">'add.js'</span></div><div class="line"><span class="keyword">let</span> sum = add(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line"><span class="built_in">console</span>.log(sum); <span class="comment">// 3</span></div></pre></td></tr></table></figure></p>
<p>导入模块的默认值不需要用<code>{}</code>进行引用，后面的名称<code>add</code>直接代表了导入的模块。</p>
<p>同样也可以先声明在导出值。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> <span class="keyword">default</span> add;</div></pre></td></tr></table></figure>
<p>在导出多个值的时候同时导出default值，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleA.js</span></div><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>, <span class="string">'black'</span> , <span class="string">'blue'</span>];</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">printColors</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  colors.forEach(<span class="function"><span class="keyword">function</span>(<span class="params">value , index</span>)</span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">  &#125;);</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;colors  , printColors , Person <span class="keyword">as</span> <span class="keyword">default</span>&#125;;</div></pre></td></tr></table></figure>
<p>此时的引入方式如下，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// moduleB.js</span></div><div class="line"><span class="keyword">import</span> Person , &#123;colors , printColrs&#125; <span class="keyword">from</span> <span class="string">'moduleA'</span>;</div></pre></td></tr></table></figure>
<h4 id="引入所有"><a href="#引入所有" class="headerlink" title="引入所有"></a>引入所有</h4><p>使用<code>import * as</code>的方式可以将一个模块导出的所有内容导入到一个对象内，接下来所有导出的内容都会以该对象的属性形式存在。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// util.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span> (<span class="params">a,b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">a , b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(a,b)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;add , min&#125;;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">'util.js'</span>;</div><div class="line">util.add(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">util.min(<span class="number">2</span>,<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>如果模块有导出default值的时候，此时的导入是以下形式。</p>
<p>// Person.js
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Person&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">createPerson</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;Person <span class="keyword">as</span> <span class="keyword">default</span> , createPerson&#125;;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> Person , * <span class="keyword">as</span> personUtil <span class="keyword">from</span> <span class="string">'Person'</span>;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">let</span> person2 = personUtil.createPerson(<span class="string">'Jim'</span>);</div></pre></td></tr></table></figure></p>
<h4 id="二次导出"><a href="#二次导出" class="headerlink" title="二次导出"></a>二次导出</h4><p>我们可以将我们import进来的模块在当前模块中再次export出去，比如一个大型的模块对外提供一个统一的调用，但它其实内部是有多个子模块合并而成的，这是一个比较典型的使用场景。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// add.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">add</span>(<span class="params">a , b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> a + b;</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;add&#125;;</div><div class="line"><span class="comment">// min.js</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">min</span>(<span class="params">a , b</span>)</span>&#123;</div><div class="line">  <span class="keyword">return</span> <span class="built_in">Math</span>.min(a,b)</div><div class="line">&#125;</div><div class="line"><span class="keyword">export</span> &#123;min&#125;;</div><div class="line"></div><div class="line"><span class="comment">// util.js</span></div><div class="line"><span class="comment">// 二次导出引入模块的内容</span></div><div class="line"><span class="keyword">import</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">'add'</span>;</div><div class="line"><span class="keyword">import</span> &#123;min&#125; <span class="keyword">from</span> <span class="string">'min'</span>;</div><div class="line"><span class="keyword">export</span>  &#123;add, min&#125;;</div><div class="line"></div><div class="line"><span class="comment">// main.js</span></div><div class="line"><span class="keyword">import</span> * <span class="keyword">as</span> util <span class="keyword">from</span> <span class="string">'util'</span>;</div><div class="line">util.add(<span class="number">1</span>,<span class="number">2</span>);</div><div class="line">util.min(<span class="number">1</span>,<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>以上的<em>util.js</em>导出了其引入模块的内容，它可以直接导出模块，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123;add&#125; <span class="keyword">from</span> <span class="string">'add'</span>;</div><div class="line"><span class="keyword">export</span> &#123;min&#125; <span class="keyword">from</span> <span class="string">'min'</span>;</div></pre></td></tr></table></figure>
<p>也可以进行重名，如
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> &#123;ADD&#125; <span class="keyword">from</span> <span class="string">'add'</span>;</div><div class="line"><span class="keyword">export</span> &#123;MIN&#125; <span class="keyword">from</span> <span class="string">'min'</span>;</div></pre></td></tr></table></figure></p>
<p>或直接使用导出全部的语法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'add'</span>;</div><div class="line"><span class="keyword">export</span> * <span class="keyword">from</span> <span class="string">'min'</span>;</div></pre></td></tr></table></figure>
<h4 id="没有导出值的模块"><a href="#没有导出值的模块" class="headerlink" title="没有导出值的模块"></a>没有导出值的模块</h4><p>不是所有的模块最终都会向外部导出值，有些模块可能用来进行全局对象的初始化或进行默认配置，这时候这些模块不会导出值，其它模块对齐进行导入操作只是为了进行模块的加载行为。
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// config.js</span></div><div class="line"></div><div class="line">global.Themes = [<span class="string">'Black'</span> , <span class="string">'Light'</span> , <span class="string">'Default'</span>];</div><div class="line"></div><div class="line"><span class="comment">// app.js</span></div><div class="line"><span class="keyword">import</span> <span class="string">'config'</span>;</div><div class="line"></div><div class="line"><span class="built_in">console</span>.log(global.Themes);</div></pre></td></tr></table></figure></p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/export" target="_blank" rel="external">export statement</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/import" target="_blank" rel="external">import statement</a></li>
<li><a href="https://github.com/amdjs/amdjs-api/wiki/AMD" target="_blank" rel="external">AMD</a></li>
<li><a href="http://wiki.commonjs.org/wiki/Modules/1.1" target="_blank" rel="external">CommonJS Modules/1.1</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Strict_mode" target="_blank" rel="external">Strict mode</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/05/30/ES6笔记-Promise对象/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/30/ES6笔记-Promise对象/" itemprop="url">ES6笔记 - Promise对象</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-30T21:30:32+08:00">
                2016-05-30
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>Promise是ES6新增的用来解决JavaScript异步编程（asynchronous programming）问题的对象，JavaScript的日常编码中需要处理大量的基于事件-回调方式的异步代码，例如用户点击一个button触发一个回调函数的执行。Node的出现以及其以callback代替events的编程方式，进一步的加强了JavaScript的异步编程模式的概念。</p>
<h3 id="异步编程形式"><a href="#异步编程形式" class="headerlink" title="异步编程形式"></a>异步编程形式</h3><p>JavaScript引擎是基于单线程的Event loop模式，单线程意味着同一时间上只能有一段代码执行，所以引擎本身需要记录所有需要处理的任务。这些任务被保存在一个事件队列Event queue中，JavaScript引擎结束当前任务后会检测事件队列继续执行下个任务，Event loop在引擎内部用来检测代码执行和调度事件队列。</p>
<p>在浏览器端异步模式是基于事件模型，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">button.addEventListener(<span class="string">'click'</span> , <span class="function"><span class="keyword">function</span>(<span class="params">event</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'按钮的click事件处理'</span>)</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'立即执行的代码'</span>);</div></pre></td></tr></table></figure>
<p>服务器端Node的callback异步模式</p>
<p>fs.readFile(‘file.txt’ , function(err , data){
  if(err){
    throw err ;
  }
  console.log(data);
});</p>
<h3 id="异步的多层嵌套"><a href="#异步的多层嵌套" class="headerlink" title="异步的多层嵌套"></a>异步的多层嵌套</h3><p>通常我们要编写某个代码模块，某块或功能本身可能递归嵌套了一系列异步子模块，这是通常代码会长成这个样子：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">task</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  methodA(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    methodB(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      methodC(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">        <span class="comment">//...</span></div><div class="line">      &#125;);</div><div class="line"></div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>所以最终代码会层层嵌套，这里<code>})</code>通常被<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">callback hell</a>，随着处理问题的复杂度的提升，<a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">callback hell</a>的问题会越来越严重，代码的可读性卓然下降。Promise对象的引入的目的之一就是解决这个问题。</p>
<h3 id="Promise简介"><a href="#Promise简介" class="headerlink" title="Promise简介"></a>Promise简介</h3><p>Promise对象是一个用来处理延迟或异步任务的对象，它是一个代理，代表了一个尚未结束但会在未来某个时间点发生的操作。例如以下是在node中读取文件的一个操作</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = readFile(<span class="string">'file.txt'</span>);</div></pre></td></tr></table></figure>
<p><code>readFile()</code>不会立即发生，而是返回一个promise对象，代表一个异步的读取文件的操作。Promise对象拥有生命周期的概念：</p>
<ul>
<li>pending state，启示待定状态，操作未完成或失败。</li>
<li>fulfilled state，操作成功完成。</li>
<li>rejected state，操作失败。</li>
</ul>
<p>以上<code>readFile</code>返回的promise对象处于pending状态，处于pending状态的promise对象在操作成功完成后会转换到fulfilled状态，如果操作失败则转换为rejected状态。Promise对象的<code>[[PromiseState]]</code>属性用来记录对象所处的状态。</p>
<h3 id="Promise的基本使用"><a href="#Promise的基本使用" class="headerlink" title="Promise的基本使用"></a>Promise的基本使用</h3><p>Promise构造器接收一个executor函数类型的参数，形式如下：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">executor</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line"></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>executor函数封装的通常是一个异步操作，它的两个参数<code>resolve</code>和<code>reject</code>是函数类型，executor函数在传入Promise后会立即执行，一旦异步操作完成后，成功则调用resolve函数返回结果只并设置promise对象为fulfilled状态，当发生错误或异常时则调用reject函数并设置promise对象为rejected状态。在调用resolve函数和reject函数时，都可以传入任何必须的参数。</p>
<p>所以可以创建Promise对象，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line">    <span class="comment">// 通常是async 操作</span></div><div class="line">    <span class="comment">//</span></div><div class="line">    <span class="keyword">if</span>(success)&#123;</div><div class="line">      resolve(result);</div><div class="line">    &#125;<span class="keyword">else</span>&#123;</div><div class="line">      reject();</div><div class="line">    &#125;</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>在创建完成后，可以使用Promise的<code>then()</code>方法来监听promise对象状态的变换，<code>then()</code>接受两个函数类型的参数——<code>onFulfilled</code>，<code>onRejected</code>，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 操作成功完成</span></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// 操作失败</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>在promise对象变为fulfilled状态后，<code>onFulfilled</code>函数会被调用，相反，promise对象变为rejected状态后，<code>onRejected</code>函数会被调用。两个参数是可选的，所以还有以下两种调用形式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 1. 只监听fulfilled状态</span></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span> <span class="title">onFulfilled</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// to do</span></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="comment">// 2. 只监听rejected状态</span></div><div class="line"></div><div class="line">promise.then(<span class="literal">undefined</span> , <span class="function"><span class="keyword">function</span> <span class="title">onRejected</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="comment">// to do</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以下是一个完整的使用Node读取文件的例子</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> fs = <span class="built_in">require</span>(<span class="string">'fs'</span>);</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">readFile</span>(<span class="params">filePath</span>)</span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line"></div><div class="line">    <span class="comment">// node下异步读取文件操作</span></div><div class="line">    fs.readFile(filePath , &#123;<span class="attr">encoding</span>:<span class="string">'utf-8'</span>&#125; , <span class="function"><span class="keyword">function</span>(<span class="params">err , data</span>)</span>&#123;</div><div class="line">      <span class="keyword">if</span>(err)&#123;</div><div class="line">        reject(err)</div><div class="line">      &#125;</div><div class="line">      resolve(data);</div><div class="line">    &#125;);</div><div class="line">  &#125;);</div><div class="line">  <span class="keyword">return</span> promise;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> filePath = __dirname + <span class="string">'/file.txt'</span>;</div><div class="line"></div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = readFile(filePath);</div><div class="line"></div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">fileContent</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'read file succeed'</span>);</div><div class="line">  <span class="built_in">console</span>.log(fileContent);</div><div class="line">&#125; , <span class="function"><span class="keyword">function</span>(<span class="params">err</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'read file failed'</span>);</div><div class="line">  <span class="built_in">console</span>.log(err);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上例子中<code>readFile()</code>函数接收文件路径，定义异步读取文件的executor函数，并返回promise对象，外部调用<code>readFile()</code>函数后会马上获得返回的promise对象，使用<code>then()</code>方法分别添加promise对象状态的监听函数，executor函数会马上执行，读取文件成功后会调用resolve函数并传入文件内容，失败调用resolve函数传入err对象。</p>
<p>需要注意的是在新建Promise对象后executor函数会马上执行，但在调用resolve或reject函数时会把它们当做任务添加到事件队列，之后再执行，正如setTimeout用来延迟执行任务一样，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">&#125;,<span class="number">1</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">2</span>);</div></pre></td></tr></table></figure>
<p>会输出
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2</div><div class="line">1</div></pre></td></tr></table></figure></p>
<p>对比来说Promise的实现，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">1</span>);</div><div class="line">  resovle()</div><div class="line">&#125;);</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"><span class="built_in">console</span>.log(<span class="number">3</span>);</div></pre></td></tr></table></figure>
<p>会输出
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">3</div><div class="line">2</div></pre></td></tr></table></figure></p>
<h3 id="catch-方法"><a href="#catch-方法" class="headerlink" title="catch()方法"></a>catch()方法</h3><p>Promise的<code>catch()</code>方法用来处理当promise对象转变为rejected状态后的回调，类似于promise.then(undefined , onRejected)，当executor执行抛出错误时也会调用该方法，所以在进行错误处理时该方法会比较有用，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle , reject</span>)</span>&#123;</div><div class="line">  reject();</div><div class="line">&#125;);</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'promise reject'</span>);</div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">promise reject</div></pre></td></tr></table></figure>
<p>抛出错误后，会调用<code>catch()</code>方法，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'executor error'</span>);</div><div class="line">&#125;);</div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error.message)</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">executor error</div></pre></td></tr></table></figure>
<p>以上例子等价于
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line">  <span class="keyword">try</span>&#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'executor error'</span>);</div><div class="line">  &#125;<span class="keyword">catch</span>(error)&#123;</div><div class="line">    reject(error)</div><div class="line">  &#125;</div><div class="line">&#125;);</div><div class="line"></div><div class="line">promise.catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error.message)</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Promise链式结构"><a href="#Promise链式结构" class="headerlink" title="Promise链式结构"></a>Promise链式结构</h3><p>Promise的<code>then()</code>方法和<code>catch()</code>方法其实都会返回一个新的Promise对象，因此利用这个特点可以实现Promise的链式调用结构。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>会输出
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">100</div><div class="line">done</div></pre></td></tr></table></figure></p>
<p>以上例子等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 =p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p2.then(<span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"done"</span>);</div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>p2只有在p1 resovle之后才执行。此外在链式调用中，可以从一个Promise传值给下一个，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 100</span></div><div class="line">    <span class="keyword">return</span> value * <span class="number">2</span>;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);         <span class="comment">// 200</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>错误的处理同样也可以使用链式结构，这需要使用<code>catch()</code>方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resovle , reject</span>)</span>&#123;</div><div class="line">  resovle(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">  <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'failed'</span>);</div><div class="line">&#125;).catch(<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(error.message); <span class="comment">// failed</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果返回的值是一个Promise对象，则么下个chain方法的调用状态取决于这个返回的Promise对象的状态，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">101</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line">p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 100</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 101</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>以上例子等价于</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">101</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = p1.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 100</span></div><div class="line">    <span class="keyword">return</span> p2;</div><div class="line">&#125;);</div><div class="line">p3.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(value);     <span class="comment">// 101</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>可以看出使用链式调用结构，可以避免callback hell问题，只要将所有异步操作封装进Promise然后按照顺序一级级返回即可，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span> <span class="title">methodA</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line">  asyncMethodA()&#123;</div><div class="line">    <span class="keyword">if</span>(success)&#123;</div><div class="line">      resovle(result);</div><div class="line">    &#125;</div><div class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</div><div class="line">  &#125;</div><div class="line">  asyncMethodA();</div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  asyncMethodB()&#123;</div><div class="line">     <span class="keyword">if</span>(success)&#123;</div><div class="line">      resovle(result);</div><div class="line">    &#125;</div><div class="line">      reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</div><div class="line">    &#125;</div><div class="line">  asyncMethodB();</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="comment">// 错误处理</span></div><div class="line">&#125;).then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  asyncMethodC()&#123;</div><div class="line">   <span class="keyword">if</span>(success)&#123;</div><div class="line">    resovle(result);</div><div class="line">  &#125;</div><div class="line">    reject(<span class="keyword">new</span> <span class="built_in">Error</span>());</div><div class="line">  &#125;</div><div class="line">  asyncMethodC();</div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">error</span>)</span>&#123;</div><div class="line">  <span class="comment">// 错误处理</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Promise-resolve-方法"><a href="#Promise-resolve-方法" class="headerlink" title="Promise.resolve()方法"></a>Promise.resolve()方法</h3><p>Promise的静态方法<code>Promise.resolve()</code>接收单一参数，并返回一个状态为fulfilled的Promise对象，该方法可接收的参数类型包括</p>
<p>1.参数可以是基本数据类型</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数为基本数据类型</span></div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resovle(<span class="number">100</span>);</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 100</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>2.可以是对象类型
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 参数为数组类型</span></div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resovle([<span class="number">100</span>,<span class="number">200</span>,<span class="number">300</span>]);</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// [100, 200, 300]</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<p>3.可以是另一个Promise对象，那么该方法会将该对象返回，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promiseA = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve</span>)</span>&#123;</div><div class="line">  resolve(<span class="number">100</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> promiseB = <span class="built_in">Promise</span>.resolve(promiseA);</div><div class="line">promiseB.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 100</span></div><div class="line">&#125;)</div></pre></td></tr></table></figure>
<p>4.一个thenable对象。所谓thenable对象是指的一个有<code>then()</code>方法的对象，如
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> thenable = &#123;</div><div class="line">  <span class="attr">then</span>: <span class="function"><span class="keyword">function</span>(<span class="params">resolve , reject</span>)</span>&#123;</div><div class="line">    resolve(<span class="number">100</span>);</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line"></div><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.resolve(thenable);</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;);</div></pre></td></tr></table></figure></p>
<h3 id="Promise-reject-方法"><a href="#Promise-reject-方法" class="headerlink" title="Promise.reject()方法"></a>Promise.reject()方法</h3><p>同<code>Promise.resolve()</code>一样，Promise.reject()也是一个静态方法，但它返回的是一个状态为rejected的Promise对象，它的参数类型与<code>Promise.resolve()</code>完全一样。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> promise = <span class="built_in">Promise</span>.reject(<span class="string">'fail reason'</span>);</div><div class="line">promise.then(<span class="function"><span class="keyword">function</span>(<span class="params">reason</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(reason); <span class="comment">// fail reason</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Promise-all"><a href="#Promise-all" class="headerlink" title="Promise.all()"></a>Promise.all()</h3><p><code>Promise.all()</code>接受一个包含多个Promise对象的iterable类型的参数，并返回一个Promise对象，可以监听它们的状态，当所有Promise对象都转换为fulfilled后才会将自己的状态设置为fulfilled，如果有其中一个Promise对象状态转换为了rejected，那么它就会转换为rejected状态。此方法可以用来监听多个异步任务的状态来执行下一步操作的行为。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">3</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="built_in">Array</span>.isArray(value));  <span class="comment">// true</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">0</span>]);              <span class="comment">// 1</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">1</span>]);              <span class="comment">// 2</span></div><div class="line">    <span class="built_in">console</span>.log(value[<span class="number">2</span>]);              <span class="comment">// 3</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<p>如果有一个Promise最终转换为rejected状态，那么<code>Promise.all()</code>返回的对象就转换为rejected状态</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">1</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    resolve(<span class="number">2</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    reject(<span class="string">'failed'</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.all([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line"></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(message); <span class="comment">// failed</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="Promise-race-方法"><a href="#Promise-race-方法" class="headerlink" title="Promise.race()方法"></a>Promise.race()方法</h3><p><code>Promise.race()</code>方法同样接受一个包含多个Promise对象的iterable类型的参数，并返回一个Promise对象，只要其中任何Promise对象的状态改变了，那么返回的Promise对象的状态也会相应改变。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> p1 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">  setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">    resolve(<span class="number">1</span>); <span class="comment">// 最先执行</span></div><div class="line">  &#125;,<span class="number">100</span>);</div><div class="line"></div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p2 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      reject(<span class="string">'failed'</span>);</div><div class="line">    &#125;,<span class="number">200</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p3 = <span class="keyword">new</span> <span class="built_in">Promise</span>(<span class="function"><span class="keyword">function</span>(<span class="params">resolve, reject</span>) </span>&#123;</div><div class="line">    setTimeout(<span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">      resolve(<span class="number">3</span>);</div><div class="line">    &#125;,<span class="number">300</span>);</div><div class="line">&#125;);</div><div class="line"></div><div class="line"><span class="keyword">let</span> p4 = <span class="built_in">Promise</span>.race([p1, p2, p3]);</div><div class="line"></div><div class="line">p4.then(<span class="function"><span class="keyword">function</span>(<span class="params">value</span>) </span>&#123;</div><div class="line">  <span class="comment">// p1优先执行了</span></div><div class="line">  <span class="built_in">console</span>.log(value); <span class="comment">// 1</span></div><div class="line">&#125;,<span class="function"><span class="keyword">function</span>(<span class="params">message</span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(message); <span class="comment">// 不会被调用了</span></div><div class="line">&#125;);</div></pre></td></tr></table></figure>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Promise" target="_blank" rel="external">Promise</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/EventLoop" target="_blank" rel="external">Concurrency model and Event Loop</a></li>
<li><a href="http://callbackhell.com/" target="_blank" rel="external">callback hell</a></li>
<li><a href="https://strongloop.com/strongblog/node-js-callback-hell-promises-generators/" target="_blank" rel="external">Managing Node.js Callback Hell with Promises, Generators and Other Approaches</a></li>
<li><a href="http://blog.carbonfive.com/2013/10/27/the-javascript-event-loop-explained/" target="_blank" rel="external">The JavaScript Event Loop: Explained</a></li>
<li><a href="https://nodesource.com/blog/understanding-the-nodejs-event-loop/" target="_blank" rel="external">Understanding the Node.js Event Loop</a></li>
<li><a href="https://promisesaplus.com/" target="_blank" rel="external">Promises/A+</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/05/25/ES6笔记-Class/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/25/ES6笔记-Class/" itemprop="url">ES6笔记 - Class</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-25T22:53:49+08:00">
                2016-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <p>JavaScript历来是基于原型的继承，这是它在实现面向对象的程序设计上与其它经典面向对象的语言不同之处。它没有类的概念，在刚开始接触基于原型实现的面向对象的实现时，通常会感到困惑，尤其是在熟悉其它类似于Java这样的OOP语言时。许多库也一直试图在JavaScript上模拟传统传统的面向对象的设计方式，比较典型的就是Google Closure Library，它的库的设计风格完全是最大程度上向Java靠拢。在软件架构实现中，面向对象的程序设计所具有的抽象，封装，多态，继承等特点，能够比较好的实现软件工程的重用性，灵活性，扩展性。ES6正式引入了class类的概念，来弥合一直以来原型继承在语法语义上的短板。ES6引入的class更多的是一种语法糖，没有引入新的面向对象的实现，其背后的实现逻辑依然是依靠之前的原型方式。</p>
<h3 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h3><p>以下是使用新的ES6语法定义一个Person类。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  intro()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(<span class="string">'Jim'</span>);</div><div class="line">person.intro(); <span class="comment">// I am Jim</span></div><div class="line"><span class="built_in">console</span>.log(person <span class="keyword">instanceof</span>  Person); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person); <span class="comment">// function</span></div><div class="line"><span class="built_in">console</span>.log(<span class="keyword">typeof</span> Person.prototype.intro); <span class="comment">// function</span></div></pre></td></tr></table></figure>
<p>以上使用<code>class</code>关键字来声明<code>Person</code>类，类名后的<code>{}</code>用来包含所有该类的方法，每个类有且仅有一个<code>constructor</code>构造器方法，用来创建和初始化类的对象，当使用关键字<code>new</code>一个对象时，会自动调用<code>contructor</code>方法。因为新的类的引入意在简化语法，所以声明方法时可以省略<code>function</code>关键字。类的实例属性必须定义在<code>constructor</code>方法或其它方法内，推荐定义在<code>constructor</code>方法。ES6的class其实现逻辑仍然基于原型继承，以下是等价的ES5实现。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>)</span>&#123;</div><div class="line">  <span class="keyword">this</span>.name = name ;</div><div class="line">&#125;</div><div class="line">Person.prototype.intro = <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person(<span class="string">'Jim'</span>);</div><div class="line">person.intro(); <span class="comment">// I am Jim</span></div></pre></td></tr></table></figure>
<p>对于前后代码，可以看到ES6的<code>contructor</code>方法对应于ES5的构造器，而ES6的其它方法，对应于ES5中定义在prototype属性上的方法。使用Babel对Person class进行ES5等价转换，以下是转换后的ES5代码，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div></pre></td><td class="code"><pre><div class="line"><span class="meta">'use strict'</span>;</div><div class="line"></div><div class="line"><span class="keyword">var</span> _createClass = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">defineProperties</span>(<span class="params">target, props</span>) </span>&#123;</div><div class="line">    <span class="keyword">for</span> (<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; props.length; i++) &#123;</div><div class="line">      <span class="keyword">var</span> descriptor = props[i];</div><div class="line">      descriptor.enumerable = descriptor.enumerable || <span class="literal">false</span>;</div><div class="line">      descriptor.configurable = <span class="literal">true</span>;</div><div class="line">      <span class="keyword">if</span> (<span class="string">"value"</span> <span class="keyword">in</span> descriptor) descriptor.writable = <span class="literal">true</span>;</div><div class="line">      <span class="built_in">Object</span>.defineProperty(target, descriptor.key, descriptor);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  <span class="keyword">return</span> <span class="function"><span class="keyword">function</span> (<span class="params">Constructor, protoProps, staticProps</span>) </span>&#123;</div><div class="line">    <span class="keyword">if</span> (protoProps) defineProperties(Constructor.prototype, protoProps);</div><div class="line">    <span class="keyword">if</span> (staticProps) defineProperties(Constructor, staticProps);</div><div class="line">    <span class="keyword">return</span> Constructor;</div><div class="line">  &#125;;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="function"><span class="keyword">function</span> _classCallCheck(<span class="params">instance, Constructor</span>) </span>&#123;</div><div class="line">  <span class="keyword">if</span> (!(instance <span class="keyword">instanceof</span> Constructor)) &#123;</div><div class="line">    <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">TypeError</span>(<span class="string">"Cannot call a class as a function"</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span> (<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.name = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _createClass(Person, [&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">'intro'</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">intro</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</div><div class="line">    &#125;</div><div class="line">  &#125;, &#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">'sayHi'</span>,</div><div class="line">    <span class="attr">value</span>: <span class="function"><span class="keyword">function</span> <span class="title">sayHi</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'hi'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;]);</div><div class="line"></div><div class="line">  <span class="keyword">return</span> Person;</div><div class="line">&#125;();</div></pre></td></tr></table></figure>
<p>以上代码也说明了ES6的class定义是如何转换到ES5的，以上的实现<code>_createClass()</code>函数接收三个参数<code>(Constructor, protoProps, staticProps)</code>,依次对应了构造器，原型属性描述对象，静态属性描述对象，<code>defineProperties()</code>方法使用<code>Object.defineProperty()</code>分别将对应的描述对象添加到相应的对象上。也解释了为什么在class中，所有实例属性应该在<code>constructor()</code>方法上定义，因为直接在类上定义的属性会被添加到原型对象上而被所有该类的实例共享，这显然时不正确的用法。</p>
<h3 id="没有作用域提升"><a href="#没有作用域提升" class="headerlink" title="没有作用域提升"></a>没有作用域提升</h3><p>ES6的class不同于function的一点是，class没有作用域提升，只有在声明类后才能创建其对象，所以以下的用法是错误的：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person(); <span class="comment">// 语法错误</span></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// ...</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="class表达式"><a href="#class表达式" class="headerlink" title="class表达式"></a>class表达式</h3><p>与函数表达式一样，class也支持class表达式，这是另一中用来定义类的方式，以下时匿名类的表达式定义</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div></pre></td></tr></table></figure>
<p>也可以定义命名的类表达式，类的名称只能在类的内部使用</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> Person = <span class="class"><span class="keyword">class</span> <span class="title">PersonClass</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">  &#125;</div><div class="line">  fnName()&#123;</div><div class="line">    <span class="built_in">console</span>.log(PersonClass.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line">peron.fnName(); <span class="comment">// PersonClass</span></div><div class="line"><span class="built_in">console</span>.log(PersonClass.name);<span class="comment">// 引用错误,PersonClass未定义</span></div></pre></td></tr></table></figure>
<h3 id="值传递"><a href="#值传递" class="headerlink" title="值传递"></a>值传递</h3><p>JavaScript中function可以当做值进行处理，既可以当做参数传递，也可以赋值给变量，还可以作为函数返回值返回，ES6眼延续了这一特性，class也同时拥有以上特性。，如：</p>
<p>class作为参数进行传递
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">ObjectFactory</span>(<span class="params">cls</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Cls();</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = ObjectFactory(Person);</div></pre></td></tr></table></figure></p>
<p>将class赋值给本地变量</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> localVar = Person ;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> localVar();</div></pre></td></tr></table></figure>
<p>类的单例模式</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> singleton = <span class="keyword">new</span> <span class="class"><span class="keyword">class</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="comment">// to do</span></div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">  intro()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">"I am "</span>+ <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;(<span class="string">'Jim'</span>);</div><div class="line">singleton.intro(); <span class="comment">// I am Jim</span></div></pre></td></tr></table></figure>
<h3 id="存取器getter和setter方法"><a href="#存取器getter和setter方法" class="headerlink" title="存取器getter和setter方法"></a>存取器getter和setter方法</h3><p>在类中同样可以定义属性访问器，用来set或get一个属性，可以在<code>set</code>和<code>get</code>关键字后添加一个属性名称<code>prop</code>，中间用空格隔开，依次来将类的属性的存取分别绑定在一个function上，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.nameRef = name ;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  set name(name)&#123;</div><div class="line">    <span class="keyword">this</span>.nameRef = name ;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'new name setted : '</span>+name);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  get name()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'name accessed'</span>);</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nameRef ;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.name = <span class="string">"Jim"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name);</div></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">new name setted : Jim</div><div class="line">name accessed</div><div class="line">Jim</div></pre></td></tr></table></figure>
<p>可以查看下<code>name</code>的属性描述符</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"></div><div class="line"><span class="keyword">var</span> descriptor = <span class="built_in">Object</span>.getOwnPropertyDescriptor(Person.prototype , <span class="string">'name'</span>);</div><div class="line"><span class="built_in">console</span>.log(<span class="string">'set'</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(<span class="string">'get'</span> <span class="keyword">in</span> descriptor); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(descriptor.enumerable); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p>以下是经Babel转义后的ES5等价代码，</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> Person = <span class="function"><span class="keyword">function</span>(<span class="params"></span>) </span>&#123;</div><div class="line">  <span class="function"><span class="keyword">function</span> <span class="title">Person</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">    _classCallCheck(<span class="keyword">this</span>, Person);</div><div class="line"></div><div class="line">    <span class="keyword">this</span>.nameRef = name;</div><div class="line">  &#125;</div><div class="line"></div><div class="line">  _createClass(Person, [&#123;</div><div class="line">    <span class="attr">key</span>: <span class="string">'name'</span>,</div><div class="line">    <span class="attr">set</span>: <span class="function"><span class="keyword">function</span> <span class="title">set</span>(<span class="params">name</span>) </span>&#123;</div><div class="line">      <span class="keyword">this</span>.nameRef = name;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'new name setted : '</span> + name);</div><div class="line">    &#125;,</div><div class="line">    <span class="attr">get</span>: <span class="function"><span class="keyword">function</span> <span class="title">get</span>(<span class="params"></span>) </span>&#123;</div><div class="line">      <span class="built_in">console</span>.log(<span class="string">'name accessed'</span>);</div><div class="line">      <span class="keyword">return</span> <span class="keyword">this</span>.nameRef;</div><div class="line">    &#125;</div><div class="line">  &#125;]);</div><div class="line">  <span class="keyword">return</span> Person;</div><div class="line">&#125;();</div><div class="line"></div><div class="line"><span class="keyword">var</span> person = <span class="keyword">new</span> Person();</div><div class="line">person.name = <span class="string">"Jim"</span>;</div><div class="line"><span class="built_in">console</span>.log(person.name);</div></pre></td></tr></table></figure>
<h3 id="计算属性名称"><a href="#计算属性名称" class="headerlink" title="计算属性名称"></a>计算属性名称</h3><p>ES6在扩展对象功能后，在对象字面量的定义时添加了计算属性名的特性，与此类似，ES6中class的方法名称和存取器名称也可以是计算名称。</p>
<p>在类的方法名上使用计算属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> introMethodName = <span class="string">'intro'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">  [introMethodName]()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span> + <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在类的存取器上使用计算属性名：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> propName = <span class="string">'name'</span>;</div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  get [propName]()&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">this</span>.nameRef ;</div><div class="line">  &#125;</div><div class="line">  set [propName](value)&#123;</div><div class="line">    <span class="keyword">this</span>.nameRef = value ;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="Generator方法"><a href="#Generator方法" class="headerlink" title="Generator方法"></a>Generator方法</h3><p>如同定义Generator函数一样，可以在类上定义Generator方法，只要在方法名称前添加<code>*</code>即可，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args)&#123;</div><div class="line">    <span class="keyword">this</span>.items = [];</div><div class="line">    <span class="keyword">this</span>.items.push(...args);</div><div class="line">  &#125;</div><div class="line">  add(...vals)&#123;</div><div class="line">    <span class="keyword">this</span>.items.push(...vals)</div><div class="line">  &#125;</div><div class="line">  *createIterator()&#123;</div><div class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> collection = <span class="keyword">new</span> Collection(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"><span class="keyword">let</span> iterator = collection.createIterator();</div><div class="line">iterator.next();<span class="comment">// &#123;value:1,done:false&#125;</span></div><div class="line">iterator.next();<span class="comment">// &#123;value:2,done:false&#125;</span></div><div class="line">iterator.next();<span class="comment">// &#123;value:3,done:false&#125;</span></div><div class="line">iterator.next();<span class="comment">// &#123;done:true&#125;</span></div></pre></td></tr></table></figure>
<p>在需要遍历对象时，可以覆盖<code>Symbol.iterator</code>方法，这样便可以使用<code>for of</code>语句对其遍历,</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Collection</span> </span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(...args)&#123;</div><div class="line">    <span class="keyword">this</span>.items = [];</div><div class="line">    <span class="keyword">this</span>.items.push(...args);</div><div class="line">  &#125;</div><div class="line">  add(...vals)&#123;</div><div class="line">    <span class="keyword">this</span>.items.push(...vals)</div><div class="line">  &#125;</div><div class="line">  *[<span class="built_in">Symbol</span>.iterator]()&#123;</div><div class="line">    <span class="keyword">yield</span> *<span class="keyword">this</span>.items.values();</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> collection = <span class="keyword">new</span> Collection(<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value collection)&#123;</div><div class="line">  <span class="built_in">console</span>.log(value) ;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>会输出
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td></tr></table></figure></p>
<h3 id="静态方法"><a href="#静态方法" class="headerlink" title="静态方法"></a>静态方法</h3><p>在ES6之前，通常会在构造器上添加方法，来模拟类的静态方法，ES6新增<code>static</code>关键字支持在类上直接添加静态方法，静态方法通常用来作为工作方法来使用。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line"></div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">  intro()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> create(name)&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">new</span> Person(name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> person = Person.create(<span class="string">'Jim'</span>);</div><div class="line">person.intro();</div></pre></td></tr></table></figure>
<h3 id="继承"><a href="#继承" class="headerlink" title="继承"></a>继承</h3><p>之前基于原型的继承实现比较繁琐，需要几个步骤才能实现继承，ES6也简化了继承操作，现在使用extends关键字可以很直白方便的完成继承,同时可以使用<code>super</code>来调用父类方法。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">  intro()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span>+ <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">super</span>(name);</div><div class="line">    <span class="keyword">this</span>.country = <span class="string">'China'</span>;</div><div class="line">  &#125;</div><div class="line">  intro()&#123;</div><div class="line">    <span class="keyword">super</span>.intro();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am Chinese.'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">let</span> chinaPerson = <span class="keyword">new</span> ChinaPerson(<span class="string">'张三'</span>);</div><div class="line">chinaPerson.intro();</div></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">I am 张三</div><div class="line">I am Chinese.</div></pre></td></tr></table></figure>
<p>需要注意的几点有:</p>
<ul>
<li><p><code>super</code>只能出现在继承类中。</p>
</li>
<li><p>构造器中可以直接单独使用<code>super()</code>，并且需要置于this关键字访问之前。以下是错误的</p>
  <figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.country = <span class="string">'China'</span>;</div><div class="line">    <span class="keyword">super</span>(name); <span class="comment">// 错误</span></div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
</li>
</ul>
<h3 id="继承静态方法"><a href="#继承静态方法" class="headerlink" title="继承静态方法"></a>继承静态方法</h3><p>父类的静态方法在子类中也是可以被继承的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">  intro()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span>+ <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> showClass()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Person'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line"> <span class="keyword">static</span> showClass()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Person'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line">ChinaPerson.showClass();</div></pre></td></tr></table></figure>
<p>会输出
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">Person</div></pre></td></tr></table></figure></p>
<p>静态方法中也可以使用super关键字调用父类方法</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">  intro()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'I am '</span>+ <span class="keyword">this</span>.name);</div><div class="line">  &#125;</div><div class="line">  <span class="keyword">static</span> showClass()&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'Person'</span>);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line"></div><div class="line"> <span class="keyword">static</span> showClass()&#123;</div><div class="line">    <span class="keyword">super</span>.showClass();</div><div class="line">    <span class="built_in">console</span>.log(<span class="string">'ChinaPerson'</span>);</div><div class="line">  &#125;</div><div class="line"></div><div class="line">&#125;</div><div class="line">ChinaPerson.showClass();</div></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">Person</div><div class="line">ChinaPerson</div></pre></td></tr></table></figure>
<h3 id="内建对象的继承"><a href="#内建对象的继承" class="headerlink" title="内建对象的继承"></a>内建对象的继承</h3><p>ES6之后所有内建对象类型也是可以被直接继承的，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">MyArray</span> <span class="keyword">extends</span> <span class="title">Array</span></span>&#123;</div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> myArr = <span class="keyword">new</span> MyArray();</div><div class="line">myArr.push(<span class="string">'Hello '</span>);</div><div class="line">myArr.push(<span class="string">'World'</span>);</div><div class="line"><span class="built_in">console</span>.log(myArr.length);</div><div class="line"><span class="built_in">console</span>.log(myArr);</div></pre></td></tr></table></figure>
<p>会输出</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">2</div><div class="line">[&quot;Hello &quot;, &quot;World&quot;]</div></pre></td></tr></table></figure>
<h3 id="在构造器中使用new-target"><a href="#在构造器中使用new-target" class="headerlink" title="在构造器中使用new.target"></a>在构造器中使用new.target</h3><p>当一个函数的构造器被调用时，<code>new.target</code>会引用<code>new</code>后面的构造器，如果函数不是使用new关键字调用<code>new.target</code>的值是undefined，因此可以在类中使用<code>new.target</code>来判断类是如何调用的。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">Person</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>(name)&#123;</div><div class="line">    <span class="built_in">console</span>.log(<span class="keyword">new</span>.target == Person);</div><div class="line">    <span class="keyword">this</span>.name = name ;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">ChinaPerson</span> <span class="keyword">extends</span> <span class="title">Person</span></span>&#123;</div><div class="line"></div><div class="line"></div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> person = <span class="keyword">new</span> Person();</div><div class="line"><span class="keyword">let</span> chinaPerson = <span class="keyword">new</span> ChinaPerson();</div><div class="line"></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure>
<p>会输出
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">true</div><div class="line">false</div></pre></td></tr></table></figure></p>
<p>可以利用<code>new.target</code>的特性来构造抽象类</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div></pre></td><td class="code"><pre><div class="line"><span class="class"><span class="keyword">class</span> <span class="title">AbstractClass</span></span>&#123;</div><div class="line">  <span class="keyword">constructor</span>()&#123;</div><div class="line">    <span class="keyword">if</span>(<span class="keyword">new</span>.target == AbstractClass)&#123;</div><div class="line">      <span class="keyword">throw</span> <span class="keyword">new</span> <span class="built_in">Error</span>(<span class="string">'该类是抽象类'</span>);</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">let</span> obj = <span class="keyword">new</span> AbstractClass(); <span class="comment">// Uncaught Error: 该类是抽象类</span></div></pre></td></tr></table></figure>
<h3 id="class的优点"><a href="#class的优点" class="headerlink" title="class的优点"></a>class的优点</h3><p>综上使用类的优点可以总结如下：</p>
<ul>
<li>语义语法更直观，易于理解。</li>
<li>如<code>let</code>关键字定义的变量以下，class没有作用域提升，语法稍严格，避免出现错误。</li>
<li>所有方法都是不可枚举的，只能是使用<code>Object.defineProperty()</code>使得方法可枚举。</li>
<li>未使用new调用class会抛出错误。</li>
</ul>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/class" target="_blank" rel="external">class expression</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Statements/class" target="_blank" rel="external">class statement</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/Method_definitions" target="_blank" rel="external">Method definitions</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes" target="_blank" rel="external">Classes</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/set" target="_blank" rel="external">setter</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/get" target="_blank" rel="external">getter</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/constructor" target="_blank" rel="external">constructor</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Object/getOwnPropertyDescriptor" target="_blank" rel="external">Object.getOwnPropertyDescriptor()</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Classes/extends" target="_blank" rel="external">extends</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/05/25/ES6笔记-Spread运算符/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/25/ES6笔记-Spread运算符/" itemprop="url">ES6笔记 - Spread运算符</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-25T21:49:48+08:00">
                2016-05-25
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>ES6引入一个名为Spread运算符，当需要多参数（如函数调用），多元素（如数组），多变量（解构变量）使用时，Spread运算符允许将表达式在所有这些所需地方展开，Spread元素符以三个点号+变量名组成，如<code>...varName</code>，以下是几种使用Spread运算符使用场景。</p>
<h4 id="函数调用"><a href="#函数调用" class="headerlink" title="函数调用"></a>函数调用</h4><p>当函数需要多个参数时，可以使用Spread操作符，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">testFn</span>(<span class="params"></span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> args = <span class="built_in">arguments</span>;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span> , l = args.length ; i &lt; l ; i++)&#123;</div><div class="line">    <span class="built_in">console</span>.log(args[i]);</div><div class="line">  &#125;</div><div class="line">&#125;</div><div class="line"><span class="keyword">var</span> nums = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>,<span class="number">4</span>] ;</div><div class="line"></div><div class="line"><span class="comment">// ES5中的实现</span></div><div class="line">testFn.apply(<span class="literal">null</span> , nums);</div><div class="line"></div><div class="line"><span class="comment">// ES6的实现</span></div><div class="line">testFn(...nums);</div></pre></td></tr></table></figure>
<p>以上的调用可以扩展至JavaScript中其它的一些方法中，比如<code>Math.max()</code>用来提取多个数值参数中的最大值，如果用此方法来筛选数组中的最大值，在ES5中需要结合<code>apply()</code>方法，如
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> largest = <span class="built_in">Math</span>.max.apply(<span class="literal">null</span> , arr);</div><div class="line"><span class="built_in">console</span>.log(largest); <span class="comment">// 4</span></div></pre></td></tr></table></figure></p>
<p>ES6中使用Spread操作符，如下</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>];</div><div class="line"><span class="keyword">var</span> largest = <span class="built_in">Math</span>.max(...arr);</div><div class="line"><span class="built_in">console</span>.log(largest); <span class="comment">// 4</span></div></pre></td></tr></table></figure>
<p>类似的还有Array的<code>push()</code>,<code>concat()</code>，<code>unshift()</code>,<code>splice()</code>方法；Math的<code>min()</code>方法。</p>
<h4 id="数组字面量的创建"><a href="#数组字面量的创建" class="headerlink" title="数组字面量的创建"></a>数组字面量的创建</h4><p>将一个数组的元素插入到另一个数组中是较为常见的操作，可以使用Spread运算符更便捷的实现此功能，如创建一个新的数组字面量,并将一个数组的元素插入到该新创建的数组字面量里，在ES5中的实现形式为</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"><span class="keyword">for</span>(<span class="keyword">var</span> i = a.length<span class="number">-1</span> ; i &gt; <span class="number">-1</span> ; i--)&#123;</div><div class="line">  b.splice(<span class="number">0</span> , <span class="number">0</span> , a[i]);</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,6]</span></div></pre></td></tr></table></figure>
<p>在ES6中
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> a = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> b = [...a,<span class="number">4</span>,<span class="number">5</span>,<span class="number">6</span>];</div><div class="line"><span class="built_in">console</span>.log(b); <span class="comment">// [1,2,3,4,5,6]</span></div></pre></td></tr></table></figure></p>
<h4 id="剩余参数"><a href="#剩余参数" class="headerlink" title="剩余参数"></a>剩余参数</h4><p>ES6中引入一个名为剩余参数(rest parameters)的特性，可以用在函数中将多个参数集合成一个数组，可用来替换arguments对象，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line"><span class="comment">// 实现对象浅复制</span></div><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> length = <span class="built_in">arguments</span>.length ;</div><div class="line">  target =  <span class="keyword">typeof</span> target !== <span class="string">"object"</span> ?  &#123;&#125; : target;</div><div class="line">  <span class="keyword">var</span> name , opt;</div><div class="line">  <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">1</span>; i &lt; length ; i++)&#123;</div><div class="line">    obj = <span class="built_in">arguments</span>[i];</div><div class="line">    <span class="keyword">if</span>(obj)&#123;</div><div class="line">      <span class="keyword">for</span>(name <span class="keyword">in</span> obj)&#123;</div><div class="line">        target[name] = obj[name];</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>在ES6中可以使用rest参数</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">extend</span>(<span class="params">target , ...objects</span>)</span>&#123;</div><div class="line">    <span class="keyword">var</span> length = objects.length ;</div><div class="line">    target =  <span class="keyword">typeof</span> target !== <span class="string">"object"</span> ?  &#123;&#125; : target;</div><div class="line">    <span class="keyword">var</span> name , obj;</div><div class="line">    <span class="keyword">for</span>(<span class="keyword">var</span> i = <span class="number">0</span>; i &lt; length ; i++)&#123;</div><div class="line">      obj = objects[i];</div><div class="line">      <span class="keyword">if</span>(obj)&#123;</div><div class="line">        <span class="keyword">for</span>(name <span class="keyword">in</span> obj)&#123;</div><div class="line">          target[name] = obj[name];</div><div class="line">        &#125;</div><div class="line">      &#125;</div><div class="line">    &#125;</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h4 id="变量解构"><a href="#变量解构" class="headerlink" title="变量解构"></a>变量解构</h4><p>在使用数组变量的解构中，可以j将数组中的某元素赋值给一个特殊的变量，这个变量的形式类似于rest参数，也是一个数组类型，如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> colors = [<span class="string">'red'</span>,<span class="string">'green'</span>,<span class="string">'black'</span>,<span class="string">'white'</span>,<span class="string">'orange'</span>];</div><div class="line"><span class="keyword">let</span> [r , g ,b ...others] = clors ;</div><div class="line"><span class="built_in">console</span>.log(others[<span class="number">0</span>]); <span class="comment">// white</span></div><div class="line"><span class="built_in">console</span>.log(others[<span class="number">1</span>]); <span class="comment">// orange</span></div></pre></td></tr></table></figure>
<p>可以用此形式完成更为简单的数组复制，在ES5中数组的赋值可以借助<code>concat()</code>方法，如
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">var</span> copy = arr.concat(); <span class="comment">// 当concat方法不传入参数时，会返回当前数组的拷贝</span></div><div class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// [1,2,3]</span></div></pre></td></tr></table></figure></p>
<p>在ES6中，使用数组的解构
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> [...copy] = arr ;</div><div class="line"><span class="built_in">console</span>.log(copy); <span class="comment">// copy</span></div></pre></td></tr></table></figure></p>
<p>以上的语义较ES5的更加明确。</p>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Spread_operator" target="_blank" rel="external">MDN Spread operator</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Functions/rest_parameters" target="_blank" rel="external">MDN Rest parameters</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Operators/Destructuring_assignment" target="_blank" rel="external">MDN Destructuring assignment</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
      

  

  
  
  

  <article class="post post-type-normal " itemscope itemtype="http://schema.org/Article">
    <link itemprop="mainEntityOfPage" href="http://monjer.github.io/2016/05/22/ES6笔记-Iterator/">

    <span hidden itemprop="author" itemscope itemtype="http://schema.org/Person">
      <meta itemprop="name" content="monjer">
      <meta itemprop="description" content="">
      <meta itemprop="image" content="/images/avatar.gif">
    </span>

    <span hidden itemprop="publisher" itemscope itemtype="http://schema.org/Organization">
      <meta itemprop="name" content="monjer's note">
    </span>

    
      <header class="post-header">

        
        
          <h1 class="post-title" itemprop="name headline">
                
                <a class="post-title-link" href="/2016/05/22/ES6笔记-Iterator/" itemprop="url">ES6笔记 - Iterator</a></h1>
        

        <div class="post-meta">
          <span class="post-time">
            
              <span class="post-meta-item-icon">
                <i class="fa fa-calendar-o"></i>
              </span>
              
                <span class="post-meta-item-text">发表于</span>
              
              <time title="创建于" itemprop="dateCreated datePublished" datetime="2016-05-22T23:06:24+08:00">
                2016-05-22
              </time>
            

            

            
          </span>

          

          
            
          

          
          

          

          

          

        </div>
      </header>
    

    <div class="post-body" itemprop="articleBody">

      
      

      
        
          
            <h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><p>集合的遍历操作基本上存在于每种语言当中，在ES6之前遍历操作主要针对的时Array类型和对象类型，使用遍历的语句时for语句，while语句和for in语句。新的ES6又添加了Set和Map等新的集合类型，此外，一直以来在DOM对象上也存在一些ArrayLike对象，NodeList等等，所有定义一套机制来为这些集合类型的数据结构提供一直的访问方式，显得十分必要。ES6添加了Iterator正是为了更好的一致性的遍历集合。</p>
<p>Iterator是可以理解为是一种协议(protocol)或接口，它定义了<code>next()</code>方法返回一个结果对象，这个对象上拥有两个属性:</p>
<ul>
<li><code>value</code>属性，用来当前遍历对象的值，</li>
<li><code>done</code>属性，返回一个布尔值表示是否遍历操作已完成，如果完成则返回true（此时的value为undefined），否则返回false。</li>
</ul>
<p>实现了Iterator的对象都成为Iterator对象，而这些对象即拥有了以上的特性。</p>
<h3 id="模拟Iterator"><a href="#模拟Iterator" class="headerlink" title="模拟Iterator"></a>模拟Iterator</h3><p>可以使用以下代码模拟Iterator的工作原理：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">makeIterator</span>(<span class="params">arrayLikeObj</span>)</span>&#123;</div><div class="line">  <span class="keyword">var</span> curIndex = <span class="number">-1</span>;</div><div class="line">  <span class="keyword">return</span> &#123;</div><div class="line">    <span class="attr">next</span>: <span class="function"><span class="keyword">function</span>(<span class="params"></span>)</span>&#123;</div><div class="line">       <span class="keyword">var</span> l = arrayLikeObj.length ;</div><div class="line">       curIndex++;</div><div class="line">       <span class="keyword">return</span> curIndex &lt; l ? &#123;<span class="attr">value</span>: arrayLikeObj[curIndex],<span class="attr">done</span>: <span class="literal">false</span>&#125;</div><div class="line">                                            :&#123;<span class="attr">done</span>:<span class="literal">true</span>,<span class="attr">value</span>:<span class="literal">undefined</span>&#125;;</div><div class="line">    &#125;</div><div class="line">  &#125;;</div><div class="line">&#125;</div><div class="line"></div><div class="line"><span class="keyword">var</span> iterator = makeIterator([<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>]);</div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<h3 id="Iterable协议"><a href="#Iterable协议" class="headerlink" title="Iterable协议"></a>Iterable协议</h3><p>Iterable协议允许JavaScript对象定义自己的遍历行为，为此对象必须实现以<code>Symbol.iterator</code>命名的属性，该属性必须返回一个iterator对象，当对象被遍历时，比如使用<code>for of</code>语句，都会直接操作这个iterator对象。所以说只要一个对象实现了<code>Symbol.iterator</code>属性，那么它就是可遍历的。所有的JavaScript内建的集合类型Array，Set，Map和String类型，以及DOM的集合类型HTMLCollection，NodeList都实现了该属性。</p>
<p>以上提到的<code>for of</code>语句结构如下：
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">for</span> (variable <span class="keyword">of</span> iterable) &#123;</div><div class="line">  statement</div><div class="line">&#125;</div></pre></td></tr></table></figure></p>
<p>它遍历iterator对象时，每次都会调用其<code>next()</code>方法，然后把返回对象的<code>value</code>属性保存到<code>variable</code>变量上，知道返回对象的<code>done</code>为true时则停止，比如访问数组：</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> str = <span class="string">""</span>;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> item <span class="keyword">of</span> arr)&#123;</div><div class="line"> str += item;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(str += item); <span class="comment">// 123</span></div><div class="line"><span class="string">`</span></div></pre></td></tr></table></figure>
<h3 id="访问默认的Iterator"><a href="#访问默认的Iterator" class="headerlink" title="访问默认的Iterator"></a>访问默认的Iterator</h3><p>使用<code>Symbol.iteraor</code>可以访问对象的iterator遍历器，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> iterator = arr[<span class="built_in">Symbol</span>.iterator]();</div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 1, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 2, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: 3, done: false&#125;</span></div><div class="line"><span class="built_in">console</span>.log(iterator.next()); <span class="comment">// Object &#123;value: undefined, done: true&#125;</span></div></pre></td></tr></table></figure>
<p>以上代码是获取了数组的iterator对象，并进行了遍历。可以定义以下方法判断一个对象是否时可遍历的</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line"><span class="function"><span class="keyword">function</span> <span class="title">isIterable</span>(<span class="params">obj</span>)</span>&#123;</div><div class="line">    <span class="keyword">return</span> <span class="keyword">typeof</span> obj[<span class="built_in">Symbol</span>.iterator] === <span class="string">"function"</span>;</div><div class="line">&#125;</div><div class="line"><span class="built_in">console</span>.log(isIterable([<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>]));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="string">"Hello World"</span>)); <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Map</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">Set</span>()));     <span class="comment">// true</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakMap</span>())); <span class="comment">// false</span></div><div class="line"><span class="built_in">console</span>.log(isIterable(<span class="keyword">new</span> <span class="built_in">WeakSet</span>())); <span class="comment">// false</span></div></pre></td></tr></table></figure>
<p><code>for of</code>语句在进行遍历之前的检测原理与以上代码类似，如果在一个没有实现<code>Symbol.iterator</code>属性的对象上使用<code>for of</code>语句会报语法错误，比如</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> obj = &#123;&#125;;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> obj)&#123; <span class="comment">// Uncaught TypeError: obj[Symbol.iterator] is not a function(…)</span></div><div class="line">  <span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用generator函数创建Iterable对象"><a href="#使用generator函数创建Iterable对象" class="headerlink" title="使用generator函数创建Iterable对象"></a>使用generator函数创建Iterable对象</h3><p>对象默认创建后是不能遍历的，但以上也提到过，只要实现<code>Symbol.iterator</code>属性的对象都是可遍历的，因此我们可以通过此方式来是一个对象变成可遍历对象，ES6使用Generator对象来完成此操作。Generator对象是有generator函数创建的一种特殊对象，它同时遵循Iterator协议和Iterable协议，generator函数是以一个添加在function关键字后的<code>*</code>标记的函数，并且结合使用新的<code>yield</code>关键字，返回这里只要知道它是在对象上实现<code>Symbol.iteraor</code>最简单的方法就可以了。</p>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> myCollection = &#123;</div><div class="line">  <span class="attr">items</span>: [],</div><div class="line">  *[<span class="built_in">Symbol</span>.iterator]():&#123;</div><div class="line">    <span class="keyword">for</span>(value <span class="keyword">of</span> <span class="keyword">this</span>.items)&#123;</div><div class="line">      <span class="keyword">yield</span> value;</div><div class="line">    &#125;</div><div class="line">  &#125;</div><div class="line">&#125;;</div><div class="line">myCollection.items.push(<span class="number">1</span>);</div><div class="line">myCollection.items.push(<span class="number">2</span>);</div><div class="line">myCollection.items.push(<span class="number">3</span>);</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> value <span class="keyword">of</span> myCollection)&#123;</div><div class="line">  <span class="built_in">console</span>.log(value);</div><div class="line">&#125;</div><div class="line"><span class="comment">// 输出打印</span></div><div class="line"><span class="comment">// 1</span></div><div class="line"><span class="comment">// 2</span></div><div class="line"><span class="comment">// 3</span></div></pre></td></tr></table></figure>
<p>以上代码中只要使用<code>yield</code>命令返回每一步的值即可。</p>
<h3 id="内建的iterable类型"><a href="#内建的iterable类型" class="headerlink" title="内建的iterable类型"></a>内建的iterable类型</h3><p>由于遍历操作的常见性，JavaScript内建对象类型已经实现了iterable协议，主要有集合类型Map,Array,Set,字符串类型String，以及DOM的NodeList类型。</p>
<ol>
<li><strong>集合类型</strong><figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">let</span> arr = [<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>];</div><div class="line"><span class="keyword">let</span> set = <span class="keyword">new</span> <span class="built_in">Set</span>([<span class="string">'red'</span>,<span class="string">'black'</span>,<span class="string">'blue'</span>]);</div><div class="line"><span class="keyword">let</span> map = <span class="keyword">new</span> <span class="built_in">Map</span>([[<span class="string">'7'</span>,<span class="number">7</span>],[<span class="string">'8'</span>,<span class="number">8</span>],[<span class="string">'9'</span>,<span class="number">9</span>]]);</div><div class="line"></div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> arr)&#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> v <span class="keyword">of</span> set)&#123;</div><div class="line">  <span class="built_in">console</span>.log(v);</div><div class="line">&#125;</div><div class="line"><span class="keyword">for</span>(<span class="keyword">let</span> entry <span class="keyword">of</span> map)&#123;</div><div class="line">  <span class="built_in">console</span>.log(entry);</div><div class="line">&#125;</div><div class="line"><span class="comment">// print</span></div><div class="line"><span class="number">1</span></div><div class="line"><span class="number">2</span></div><div class="line"><span class="number">3</span></div><div class="line">red</div><div class="line">black</div><div class="line">blue</div><div class="line">[<span class="string">"7"</span>, <span class="number">7</span>]</div><div class="line">[<span class="string">"8"</span>, <span class="number">8</span>]</div><div class="line">[<span class="string">"9"</span>, <span class="number">9</span>]</div></pre></td></tr></table></figure>
</li>
</ol>
<p>此外，三个集合类型都实现了相同名称的方法<code>keys()</code>,<code>values()</code>,<code>entries()</code>，它们都会返回一个新的iterator对象用于遍历操作。</p>
<ol>
<li><strong>String类型</strong>
String类型一直依赖操作形式上都与Array类型相似，如可以使用括号记法来访问每个字符，也有length属性返回字符长度，也可以实现了<code>Symbol.iterator</code>属性，返回一个iterator对象遍历每个字符。</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> str = <span class="string">'hello'</span>;</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> c <span class="keyword">of</span> str) &#123;</div><div class="line">    <span class="built_in">console</span>.log(c);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>输出
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">h</div><div class="line">e</div><div class="line">l</div><div class="line">l</div><div class="line">o</div></pre></td></tr></table></figure></p>
<ol>
<li><strong>NodeList类型</strong>
DOM对象的NodeList代表了在文档中一组DOM对象的集合，经常操作DOM对象的人对它并不陌生，以前在遍历NodeList对象时，我们通常使用for循环，ES6后NodeList也如Array一样实现了iterable协议，因此现在可以使用<code>for of</code>遍历NodeList对象，如：</li>
</ol>
<figure class="highlight js"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line"><span class="keyword">var</span> divs = <span class="built_in">document</span>.getElementsByTagName(<span class="string">"div"</span>);</div><div class="line"></div><div class="line"><span class="keyword">for</span> (<span class="keyword">let</span> div <span class="keyword">of</span> divs) &#123;</div><div class="line">    <span class="comment">// do something</span></div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="使用iterable语法的场景"><a href="#使用iterable语法的场景" class="headerlink" title="使用iterable语法的场景"></a>使用iterable语法的场景</h3><p>以下是几个在JavaScript中使用iterable的表达式或语法。</p>
<ol>
<li><strong>for of语句</strong></li>
<li><strong>Spread运算符</strong></li>
<li><strong>yield语句</strong></li>
<li><strong>变量的解构赋值</strong></li>
<li><strong>Set，Map，Array，WeakMap，WeakSet构造器的参数</strong></li>
</ol>
<h3 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h3><ul>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Iteration_protocols" target="_blank" rel="external">Iteration protocols</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Reference/Global_Objects/Symbol/iterator" target="_blank" rel="external">Symbol.iterator</a></li>
<li><a href="https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Iterators_and_Generators" target="_blank" rel="external">Iterators and generators</a></li>
</ul>

          
        
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <div>
      
    </div>

    <footer class="post-footer">
      

      

      

      
      
        <div class="post-eof"></div>
      
    </footer>
  </article>


    
  </section>

  
  <nav class="pagination">
    <span class="page-number current">1</span><a class="page-number" href="/page/2/">2</a><span class="space">&hellip;</span><a class="page-number" href="/page/14/">14</a><a class="extend next" rel="next" href="/page/2/"><i class="fa fa-angle-right"></i></a>
  </nav>



          </div>
          


          

        </div>
        
          
  
  <div class="sidebar-toggle">
    <div class="sidebar-toggle-line-wrap">
      <span class="sidebar-toggle-line sidebar-toggle-line-first"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-middle"></span>
      <span class="sidebar-toggle-line sidebar-toggle-line-last"></span>
    </div>
  </div>

  <aside id="sidebar" class="sidebar">
    <div class="sidebar-inner">

      

      

      <section class="site-overview sidebar-panel sidebar-panel-active">
        <div class="site-author motion-element" itemprop="author" itemscope itemtype="http://schema.org/Person">
          <img class="site-author-image" itemprop="image"
               src="/images/avatar.gif"
               alt="monjer" />
          <p class="site-author-name" itemprop="name">monjer</p>
           
              <p class="site-description motion-element" itemprop="description"></p>
          
        </div>
        <nav class="site-state motion-element">

          
            <div class="site-state-item site-state-posts">
              <a href="/archives">
                <span class="site-state-item-count">136</span>
                <span class="site-state-item-name">日志</span>
              </a>
            </div>
          

          

          
            
            
            <div class="site-state-item site-state-tags">
              <a href="/tags/index.html">
                <span class="site-state-item-count">84</span>
                <span class="site-state-item-name">标签</span>
              </a>
            </div>
          

        </nav>

        
          <div class="feed-link motion-element">
            <a href="/atom.xml" rel="alternate">
              <i class="fa fa-rss"></i>
              RSS
            </a>
          </div>
        

        <div class="links-of-author motion-element">
          
        </div>

        
        

        
        

        


      </section>

      

      

    </div>
  </aside>


        
      </div>
    </main>

    <footer id="footer" class="footer">
      <div class="footer-inner">
        <div class="copyright" >
  
  &copy; 
  <span itemprop="copyrightYear">2017</span>
  <span class="with-love">
    <i class="fa fa-heart"></i>
  </span>
  <span class="author" itemprop="copyrightHolder">monjer</span>
</div>


<div class="powered-by">
  由 <a class="theme-link" href="https://hexo.io">Hexo</a> 强力驱动
</div>

<div class="theme-info">
  主题 -
  <a class="theme-link" href="https://github.com/iissnan/hexo-theme-next">
    NexT.Muse
  </a>
</div>


        

        
      </div>
    </footer>

    
      <div class="back-to-top">
        <i class="fa fa-arrow-up"></i>
        
      </div>
    

  </div>

  

<script type="text/javascript">
  if (Object.prototype.toString.call(window.Promise) !== '[object Function]') {
    window.Promise = null;
  }
</script>









  












  
  <script type="text/javascript" src="/lib/jquery/index.js?v=2.1.3"></script>

  
  <script type="text/javascript" src="/lib/fastclick/lib/fastclick.min.js?v=1.0.6"></script>

  
  <script type="text/javascript" src="/lib/jquery_lazyload/jquery.lazyload.js?v=1.9.7"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/velocity/velocity.ui.min.js?v=1.2.1"></script>

  
  <script type="text/javascript" src="/lib/fancybox/source/jquery.fancybox.pack.js?v=2.1.5"></script>


  


  <script type="text/javascript" src="/js/src/utils.js?v=5.1.1"></script>

  <script type="text/javascript" src="/js/src/motion.js?v=5.1.1"></script>



  
  

  

  


  <script type="text/javascript" src="/js/src/bootstrap.js?v=5.1.1"></script>



  


  




	





  





  





  






  





  

  

  

  

  


</body>
</html>
