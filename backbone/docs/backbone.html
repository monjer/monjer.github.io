<!DOCTYPE html>

<html>
<head>
  <title>backbone.js</title>
  <meta http-equiv="content-type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, target-densitydpi=160dpi, initial-scale=1.0; maximum-scale=1.0; user-scalable=0;">
  <link rel="stylesheet" media="all" href="docco.css" />
</head>
<body>
  <div id="container">
    <div id="background"></div>
    
    <ul class="sections">
        
          <li id="title">
              <div class="annotation">
                  <h1>backbone.js</h1>
              </div>
          </li>
        
        
        
        <li id="section-1">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-1">&#182;</a>
              </div>
              <pre><code>Backbone.js <span class="hljs-number">1.3</span><span class="hljs-number">.3</span>
</code></pre>
            </div>
            
        </li>
        
        
        <li id="section-2">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-2">&#182;</a>
              </div>
              <pre><code>(c) <span class="hljs-number">2010</span><span class="hljs-number">-2016</span> Jeremy Ashkenas, DocumentCloud and Investigative Reporters &amp; Editors
Backbone may be freely distributed under the MIT license.
For all details and documentation:
http:<span class="hljs-comment">//backbonejs.org</span>
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>
(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">factory</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-3">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-3">&#182;</a>
              </div>
              <p>建立root对象，在浏览器中是<code>window</code> (<code>self</code>) ，在服务器端是<code>global</code>。我们使用<code>self</code>而不是<code>window</code>(<code>self</code>)，为了支持
<code>WebWorker</code></p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> root = (<span class="hljs-keyword">typeof</span> self == <span class="hljs-string">'object'</span> &amp;&amp; self.self === self &amp;&amp; self) ||
            (<span class="hljs-keyword">typeof</span> global == <span class="hljs-string">'object'</span> &amp;&amp; global.global === global &amp;&amp; global);</pre></div></div>
            
        </li>
        
        
        <li id="section-4">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-4">&#182;</a>
              </div>
              <p>根据当前环境设置Backbone。先从AMD开始。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> define === <span class="hljs-string">'function'</span> &amp;&amp; define.amd) {
    define([<span class="hljs-string">'underscore'</span>, <span class="hljs-string">'jquery'</span>, <span class="hljs-string">'exports'</span>], <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">_, $, exports</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-5">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-5">&#182;</a>
              </div>
              <p>导出到全局，即使是在AMD下，为的是防止其它脚本需要全局环境下的Backbone。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      root.Backbone = factory(root, exports, _, $);
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-6">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-6">&#182;</a>
              </div>
              <p>接下来是在Node.js或CommonJS下。jQuery可能不是必须的模块。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> exports !== <span class="hljs-string">'undefined'</span>) {
    <span class="hljs-keyword">var</span> _ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'underscore'</span>), $;
    <span class="hljs-keyword">try</span> { $ = <span class="hljs-built_in">require</span>(<span class="hljs-string">'jquery'</span>); } <span class="hljs-keyword">catch</span> (e) {}
    factory(root, exports, _, $);</pre></div></div>
            
        </li>
        
        
        <li id="section-7">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-7">&#182;</a>
              </div>
              <p>最后是在浏览器环境下。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  } <span class="hljs-keyword">else</span> {
    root.Backbone = factory(root, {}, root._, (root.jQuery || root.Zepto || root.ender || root.$));
  }

})(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">root, Backbone, _, $</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-8">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-8">&#182;</a>
              </div>
              <h2 id="-initial-setup">初始化设置 - Initial Setup</h2>

            </div>
            
        </li>
        
        
        <li id="section-9">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-9">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-10">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-10">&#182;</a>
              </div>
              <p>保存上一个<code>Backbone</code>变量的值，为的是如果之后调用<code>noConflict</code>后，仍能恢复它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> previousBackbone = root.Backbone;</pre></div></div>
            
        </li>
        
        
        <li id="section-11">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-11">&#182;</a>
              </div>
              <p>创建一个本地的指向数组常用方法的引用，我们稍后会用到它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> slice = <span class="hljs-built_in">Array</span>.prototype.slice;</pre></div></div>
            
        </li>
        
        
        <li id="section-12">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-12">&#182;</a>
              </div>
              <p>当前库的版本。需要与<code>package.json</code>中的version保持一致。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.VERSION = <span class="hljs-string">'1.3.3'</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-13">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-13">&#182;</a>
              </div>
              <p>For Backbone’s purposes, jQuery, Zepto, Ender, or My Library (kidding) owns
the <code>$</code> variable.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.$ = $;</pre></div></div>
            
        </li>
        
        
        <li id="section-14">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-14">&#182;</a>
              </div>
              <p>在<em>noConflict</em>模式下运行Backbone.js，将<code>Backbone</code>变量的控制权返回给之前的所有者。返回Backbone对象的引用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.noConflict = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    root.Backbone = previousBackbone;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-15">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-15">&#182;</a>
              </div>
              <p>开启<code>emulateHTTP</code>参数，支持传统的HTTP服务器。此选项设置后，会通过<code>_method</code>参数和设置一个<code>X-Http-Method-Override</code>
消息头，来伪装<code>&quot;PATCH&quot;</code>, <code>&quot;PUT&quot;</code> 和 <code>&quot;DELETE&quot;</code>请求。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.emulateHTTP = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-16">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-16">&#182;</a>
              </div>
              <p>开启<code>emulateJSON</code>参数，以支持那些传统的服务器，它们无法处理<code>application/json</code>请求…这会以<code>application/x-www-form-urlencoded</code>格式
编码消息体，将模型数据以表单形式发送出去，并参数名称为<code>model</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.emulateJSON = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-17">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-17">&#182;</a>
              </div>
              <p>将Backbone类的方法代理给Underscore的函数，封装model的<code>attributes</code>对象或collection的<code>models</code>数组，将其隐藏在后面。</p>
<p>collection.filter(function(model) { return model.get(‘age’) &gt; 10 });
collection.each(this.addView);</p>
<p><code>Function#apply</code>可能比较慢，所以如果我们提前知道方法参数的个数，我们会直接调用函数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> addMethod = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">length, method, attribute</span>) </span>{
    <span class="hljs-keyword">switch</span> (length) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">return</span> _[method](<span class="hljs-keyword">this</span>[attribute]);
      };
      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">value</span>) </span>{
        <span class="hljs-keyword">return</span> _[method](<span class="hljs-keyword">this</span>[attribute], value);
      };
      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">iteratee, context</span>) </span>{
        <span class="hljs-keyword">return</span> _[method](<span class="hljs-keyword">this</span>[attribute], cb(iteratee, <span class="hljs-keyword">this</span>), context);
      };
      <span class="hljs-keyword">case</span> <span class="hljs-number">4</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">iteratee, defaultVal, context</span>) </span>{
        <span class="hljs-keyword">return</span> _[method](<span class="hljs-keyword">this</span>[attribute], cb(iteratee, <span class="hljs-keyword">this</span>), defaultVal, context);
      };
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        <span class="hljs-keyword">var</span> args = slice.call(<span class="hljs-built_in">arguments</span>);
        args.unshift(<span class="hljs-keyword">this</span>[attribute]);
        <span class="hljs-keyword">return</span> _[method].apply(_, args);
      };
    }
  };
  <span class="hljs-keyword">var</span> addUnderscoreMethods = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">Class, methods, attribute</span>) </span>{
    _.each(methods, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">length, method</span>) </span>{
      <span class="hljs-keyword">if</span> (_[method]) Class.prototype[method] = addMethod(length, method, attribute);
    });
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-18">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-18">&#182;</a>
              </div>
              <p>支持 <code>collection.sortBy(&#39;attr&#39;)</code> 和 <code>collection.findWhere({id: 1})</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> cb = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">iteratee, instance</span>) </span>{
    <span class="hljs-keyword">if</span> (_.isFunction(iteratee)) <span class="hljs-keyword">return</span> iteratee;
    <span class="hljs-keyword">if</span> (_.isObject(iteratee) &amp;&amp; !instance._isModel(iteratee)) <span class="hljs-keyword">return</span> modelMatcher(iteratee);
    <span class="hljs-keyword">if</span> (_.isString(iteratee)) <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{ <span class="hljs-keyword">return</span> model.get(iteratee); };
    <span class="hljs-keyword">return</span> iteratee;
  };
  <span class="hljs-keyword">var</span> modelMatcher = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) </span>{
    <span class="hljs-keyword">var</span> matcher = _.matches(attrs);
    <span class="hljs-keyword">return</span> <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">return</span> matcher(model.attributes);
    };
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-19">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-19">&#182;</a>
              </div>
              <h2 id="-backbone-events">事件 - Backbone.Events</h2>

            </div>
            
        </li>
        
        
        <li id="section-20">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-20">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-21">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-21">&#182;</a>
              </div>
              <p>一个可以混入<em>任何对象</em>的模型，为的是提供对象自定义事件频道的功能。你可以使用<code>on</code>在事件上绑定一个回调，
也可以使用<code>off</code>将回调移除；<code>trigger</code>ing一个事件会依次触发所有回调。</p>
<pre><code><span class="hljs-keyword">var</span> object = {};
_.extend(object, Backbone.Events);
object.on(<span class="hljs-string">'expand'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ alert(<span class="hljs-string">'expanded'</span>); });
object.trigger(<span class="hljs-string">'expand'</span>);
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> Events = Backbone.Events = {};</pre></div></div>
            
        </li>
        
        
        <li id="section-22">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-22">&#182;</a>
              </div>
              <p>用来分割事件字符串的正则表达式。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> eventSplitter = <span class="hljs-regexp">/\s+/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-23">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-23">&#182;</a>
              </div>
              <p>遍历标准的<code>event, callback</code>（同时也支持巧妙的多空白符分割的事件<code>&quot;change blur&quot;, callback</code>，以及jQuery风格的事件映射<code>{event: callback}</code>）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> eventsApi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">iteratee, events, name, callback, opts</span>) </span>{
    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, names;
    <span class="hljs-keyword">if</span> (name &amp;&amp; <span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'object'</span>) {</pre></div></div>
            
        </li>
        
        
        <li id="section-24">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-24">&#182;</a>
              </div>
              <p>处理事件映射。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (callback !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> &amp;&amp; <span class="hljs-string">'context'</span> <span class="hljs-keyword">in</span> opts &amp;&amp; opts.context === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) opts.context = callback;
      <span class="hljs-keyword">for</span> (names = _.keys(name); i &lt; names.length ; i++) {
        events = eventsApi(iteratee, events, names[i], name[names[i]], opts);
      }
    } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (name &amp;&amp; eventSplitter.test(name)) {</pre></div></div>
            
        </li>
        
        
        <li id="section-25">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-25">&#182;</a>
              </div>
              <p>处理空白符分割的事件名称，单独的对其进行代理。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (names = name.split(eventSplitter); i &lt; names.length; i++) {
        events = iteratee(events, names[i], callback, opts);
      }
    } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-26">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-26">&#182;</a>
              </div>
              <p>最终，标准的事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      events = iteratee(events, name, callback, opts);
    }
    <span class="hljs-keyword">return</span> events;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-27">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-27">&#182;</a>
              </div>
              <p>将一个事件绑定到<code>callback</code>函数上。传入<code>&quot;all&quot;</code>会将回调绑定到所有触发的事件上。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.on = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, callback, context</span>) </span>{
    <span class="hljs-keyword">return</span> internalOn(<span class="hljs-keyword">this</span>, name, callback, context);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-28">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-28">&#182;</a>
              </div>
              <p>在公共API上保护<code>listening</code>参数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> internalOn = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, name, callback, context, listening</span>) </span>{
    obj._events = eventsApi(onApi, obj._events || {}, name, callback, {
      <span class="hljs-attr">context</span>: context,
      <span class="hljs-attr">ctx</span>: obj,
      <span class="hljs-attr">listening</span>: listening
    });

    <span class="hljs-keyword">if</span> (listening) {
      <span class="hljs-keyword">var</span> listeners = obj._listeners || (obj._listeners = {});
      listeners[listening.id] = listening;
    }

    <span class="hljs-keyword">return</span> obj;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-29">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-29">&#182;</a>
              </div>
              <p><code>on</code>的反转版本。告诉<strong>this</strong>对象监听另一个对象的事件…跟踪监听的对象，以便之后更容易解绑。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.listenTo = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, name, callback</span>) </span>{
    <span class="hljs-keyword">if</span> (!obj) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> id = obj._listenId || (obj._listenId = _.uniqueId(<span class="hljs-string">'l'</span>));
    <span class="hljs-keyword">var</span> listeningTo = <span class="hljs-keyword">this</span>._listeningTo || (<span class="hljs-keyword">this</span>._listeningTo = {});
    <span class="hljs-keyword">var</span> listening = listeningTo[id];</pre></div></div>
            
        </li>
        
        
        <li id="section-30">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-30">&#182;</a>
              </div>
              <p>这个对象还没有监听<code>obj</code>对象的事件。
设置必须的引用，跟踪所有监听的回调。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!listening) {
      <span class="hljs-keyword">var</span> thisId = <span class="hljs-keyword">this</span>._listenId || (<span class="hljs-keyword">this</span>._listenId = _.uniqueId(<span class="hljs-string">'l'</span>));
      listening = listeningTo[id] = {<span class="hljs-attr">obj</span>: obj, <span class="hljs-attr">objId</span>: id, <span class="hljs-attr">id</span>: thisId, <span class="hljs-attr">listeningTo</span>: listeningTo, <span class="hljs-attr">count</span>: <span class="hljs-number">0</span>};
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-31">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-31">&#182;</a>
              </div>
              <p>在obj上绑定callbacks，在listening对象追踪它们。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    internalOn(obj, name, callback, <span class="hljs-keyword">this</span>, listening);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-32">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-32">&#182;</a>
              </div>
              <p>reducing API，在<code>events</code>对象上添加回调。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> onApi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">events, name, callback, options</span>) </span>{
    <span class="hljs-keyword">if</span> (callback) {
      <span class="hljs-keyword">var</span> handlers = events[name] || (events[name] = []);
      <span class="hljs-keyword">var</span> context = options.context, ctx = options.ctx, listening = options.listening;
      <span class="hljs-keyword">if</span> (listening) listening.count++;

      handlers.push({<span class="hljs-attr">callback</span>: callback, <span class="hljs-attr">context</span>: context, <span class="hljs-attr">ctx</span>: context || ctx, <span class="hljs-attr">listening</span>: listening});
    }
    <span class="hljs-keyword">return</span> events;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-33">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-33">&#182;</a>
              </div>
              <p>移除一个或多个回调。如果<code>context</code>是null，移除那个函数的所有回调。如果<code>callback</code>是null，
移除那个event的所有回调。如果<code>name</code>是null,移除所有事件绑定的所有callback。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.off = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, callback, context</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._events) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">this</span>._events = eventsApi(offApi, <span class="hljs-keyword">this</span>._events, name, callback, {
      <span class="hljs-attr">context</span>: context,
      <span class="hljs-attr">listeners</span>: <span class="hljs-keyword">this</span>._listeners
    });
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-34">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-34">&#182;</a>
              </div>
              <p>告诉这个对象不再监听给定的事件…或不再监听它当前正在监听的对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.stopListening = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, name, callback</span>) </span>{
    <span class="hljs-keyword">var</span> listeningTo = <span class="hljs-keyword">this</span>._listeningTo;
    <span class="hljs-keyword">if</span> (!listeningTo) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> ids = obj ? [obj._listenId] : _.keys(listeningTo);

    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; ids.length; i++) {
      <span class="hljs-keyword">var</span> listening = listeningTo[ids[i]];</pre></div></div>
            
        </li>
        
        
        <li id="section-35">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-35">&#182;</a>
              </div>
              <p>如果listening对象不存在，则对象当前没有监听obj。尽早中断。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!listening) <span class="hljs-keyword">break</span>;

      listening.obj.off(name, callback, <span class="hljs-keyword">this</span>);
    }

    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-36">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-36">&#182;</a>
              </div>
              <p>reducing API，从<code>events</code>对象上移除一个回调。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> offApi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">events, name, callback, options</span>) </span>{
    <span class="hljs-keyword">if</span> (!events) <span class="hljs-keyword">return</span>;

    <span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>, listening;
    <span class="hljs-keyword">var</span> context = options.context, listeners = options.listeners;</pre></div></div>
            
        </li>
        
        
        <li id="section-37">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-37">&#182;</a>
              </div>
              <p>删除所有事件监听器，丢弃events对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!name &amp;&amp; !callback &amp;&amp; !context) {
      <span class="hljs-keyword">var</span> ids = _.keys(listeners);
      <span class="hljs-keyword">for</span> (; i &lt; ids.length; i++) {
        listening = listeners[ids[i]];
        <span class="hljs-keyword">delete</span> listeners[listening.id];
        <span class="hljs-keyword">delete</span> listening.listeningTo[listening.objId];
      }
      <span class="hljs-keyword">return</span>;
    }

    <span class="hljs-keyword">var</span> names = name ? [name] : _.keys(events);
    <span class="hljs-keyword">for</span> (; i &lt; names.length; i++) {
      name = names[i];
      <span class="hljs-keyword">var</span> handlers = events[name];</pre></div></div>
            
        </li>
        
        
        <li id="section-38">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-38">&#182;</a>
              </div>
              <p>如果没有存储事件则跳出。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!handlers) <span class="hljs-keyword">break</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-39">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-39">&#182;</a>
              </div>
              <p>如果有剩余事件则替换events对象。否则，清除它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> remaining = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> j = <span class="hljs-number">0</span>; j &lt; handlers.length; j++) {
        <span class="hljs-keyword">var</span> handler = handlers[j];
        <span class="hljs-keyword">if</span> (
          callback &amp;&amp; callback !== handler.callback &amp;&amp;
            callback !== handler.callback._callback ||
              context &amp;&amp; context !== handler.context
        ) {
          remaining.push(handler);
        } <span class="hljs-keyword">else</span> {
          listening = handler.listening;
          <span class="hljs-keyword">if</span> (listening &amp;&amp; --listening.count === <span class="hljs-number">0</span>) {
            <span class="hljs-keyword">delete</span> listeners[listening.id];
            <span class="hljs-keyword">delete</span> listening.listeningTo[listening.objId];
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-40">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-40">&#182;</a>
              </div>
              <p>如果列表中有事件，更新后面的事件。否则，清除它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (remaining.length) {
        events[name] = remaining;
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">delete</span> events[name];
      }
    }
    <span class="hljs-keyword">return</span> events;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-41">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-41">&#182;</a>
              </div>
              <p>绑定一个事件，只能触发一次的。回调在第一次调用后，它的监听器就会被删除。如果多个事件以空白分隔符语法传入，
处理器会在每个事件上触发一次，而不是在所有事件的组合上触发一次。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.once = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name, callback, context</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-42">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-42">&#182;</a>
              </div>
              <p>将事件映射到<code>{event: once}</code>对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> events = eventsApi(onceMap, {}, name, callback, _.bind(<span class="hljs-keyword">this</span>.off, <span class="hljs-keyword">this</span>));
    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> name === <span class="hljs-string">'string'</span> &amp;&amp; context == <span class="hljs-literal">null</span>) callback = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.on(events, callback, context);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-43">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-43">&#182;</a>
              </div>
              <p><code>once</code>的反转版本。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.listenToOnce = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj, name, callback</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-44">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-44">&#182;</a>
              </div>
              <p>将事件映射到<code>{event: once}</code>对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> events = eventsApi(onceMap, {}, name, callback, _.bind(<span class="hljs-keyword">this</span>.stopListening, <span class="hljs-keyword">this</span>, obj));
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.listenTo(obj, events);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-45">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-45">&#182;</a>
              </div>
              <p>将事件回调压缩到一个<code>{event: onceWrapper}</code>的map中去。在事件调用后，<code>offer</code>会解绑<code>onceWrapper</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> onceMap = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">map, name, callback, offer</span>) </span>{
    <span class="hljs-keyword">if</span> (callback) {
      <span class="hljs-keyword">var</span> once = map[name] = _.once(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        offer(name, once);
        callback.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      });
      once._callback = callback;
    }
    <span class="hljs-keyword">return</span> map;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-46">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-46">&#182;</a>
              </div>
              <p>触发一个或多个事件，调用所有绑定的回调。除了事件名称参数外，回调的参数与<code>trigger</code>函数的参数相同（除非你在监听
<code>all</code>事件，这会使得回调接收到的第一个参数为事件的真实名字）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.trigger = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">name</span>) </span>{
    <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._events) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;

    <span class="hljs-keyword">var</span> length = <span class="hljs-built_in">Math</span>.max(<span class="hljs-number">0</span>, <span class="hljs-built_in">arguments</span>.length - <span class="hljs-number">1</span>);
    <span class="hljs-keyword">var</span> args = <span class="hljs-built_in">Array</span>(length);
    <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; length; i++) args[i] = <span class="hljs-built_in">arguments</span>[i + <span class="hljs-number">1</span>];

    eventsApi(triggerApi, <span class="hljs-keyword">this</span>._events, name, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, args);
    <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-47">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-47">&#182;</a>
              </div>
              <p>处理触发合适的事件回调。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> triggerApi = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">objEvents, name, callback, args</span>) </span>{
    <span class="hljs-keyword">if</span> (objEvents) {
      <span class="hljs-keyword">var</span> events = objEvents[name];
      <span class="hljs-keyword">var</span> allEvents = objEvents.all;
      <span class="hljs-keyword">if</span> (events &amp;&amp; allEvents) allEvents = allEvents.slice();
      <span class="hljs-keyword">if</span> (events) triggerEvents(events, args);
      <span class="hljs-keyword">if</span> (allEvents) triggerEvents(allEvents, [name].concat(args));
    }
    <span class="hljs-keyword">return</span> objEvents;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-48">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-48">&#182;</a>
              </div>
              <p>一个难于理解，但却优化过的内部派发函数，用来触发事件。
尝试保持常用用例的速度（多数的Backbone事件有3个参数）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> triggerEvents = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">events, args</span>) </span>{
    <span class="hljs-keyword">var</span> ev, i = <span class="hljs-number">-1</span>, l = events.length, a1 = args[<span class="hljs-number">0</span>], a2 = args[<span class="hljs-number">1</span>], a3 = args[<span class="hljs-number">2</span>];
    <span class="hljs-keyword">switch</span> (args.length) {
      <span class="hljs-keyword">case</span> <span class="hljs-number">0</span>: <span class="hljs-keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx); <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">1</span>: <span class="hljs-keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1); <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">2</span>: <span class="hljs-keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2); <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">case</span> <span class="hljs-number">3</span>: <span class="hljs-keyword">while</span> (++i &lt; l) (ev = events[i]).callback.call(ev.ctx, a1, a2, a3); <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">default</span>: <span class="hljs-keyword">while</span> (++i &lt; l) (ev = events[i]).callback.apply(ev.ctx, args); <span class="hljs-keyword">return</span>;
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-49">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-49">&#182;</a>
              </div>
              <p>保持向后兼容性的别名。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Events.bind   = Events.on;
  Events.unbind = Events.off;</pre></div></div>
            
        </li>
        
        
        <li id="section-50">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-50">&#182;</a>
              </div>
              <p>将<code>Backbone</code>对象当做全局的事件中心，为那些需要全局”pubsub”的folks准备的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Backbone, Events);</pre></div></div>
            
        </li>
        
        
        <li id="section-51">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-51">&#182;</a>
              </div>
              <h2 id="-backbone-model">模型 - Backbone.Model</h2>

            </div>
            
        </li>
        
        
        <li id="section-52">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-52">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-53">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-53">&#182;</a>
              </div>
              <p>Backbone的 <strong>Models</strong>是框架内的基本数据对象 – 经常代表了服务器端数据库表的一个行。
一些离散的数据块，和许多有用的相关方法，用来在这些数据上执行计算和进行转换。</p>

            </div>
            
        </li>
        
        
        <li id="section-54">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-54">&#182;</a>
              </div>
              <p>根据给定的属性，创建一个新的模式model。会为你自动生成一个客户端id（<code>cid</code>）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> Model = Backbone.Model = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attributes, options</span>) </span>{
    <span class="hljs-keyword">var</span> attrs = attributes || {};
    options || (options = {});
    <span class="hljs-keyword">this</span>.cid = _.uniqueId(<span class="hljs-keyword">this</span>.cidPrefix);
    <span class="hljs-keyword">this</span>.attributes = {};
    <span class="hljs-keyword">if</span> (options.collection) <span class="hljs-keyword">this</span>.collection = options.collection;
    <span class="hljs-keyword">if</span> (options.parse) attrs = <span class="hljs-keyword">this</span>.parse(attrs, options) || {};
    <span class="hljs-keyword">var</span> defaults = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'defaults'</span>);
    attrs = _.defaults(_.extend({}, defaults, attrs), defaults);
    <span class="hljs-keyword">this</span>.set(attrs, options);
    <span class="hljs-keyword">this</span>.changed = {};
    <span class="hljs-keyword">this</span>.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-55">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-55">&#182;</a>
              </div>
              <p>将所有可继承方法添加到Model的prototype上。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Model.prototype, Events, {</pre></div></div>
            
        </li>
        
        
        <li id="section-56">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-56">&#182;</a>
              </div>
              <p>一个所有属性的hash，当前值和上一个值是不同的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    changed: <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-57">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-57">&#182;</a>
              </div>
              <p>上一次校验失败后的返回值。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    validationError: <span class="hljs-literal">null</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-58">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-58">&#182;</a>
              </div>
              <p>JSON<code>id</code>属性的默认名称是<code>&quot;id&quot;</code>。MongoDB和CouchDB的用户可能会把名称替换为<code>&quot;_id&quot;</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    idAttribute: <span class="hljs-string">'id'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-59">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-59">&#182;</a>
              </div>
              <p>前缀是用来创建客户端id，此id用来在本地标识models。如果你的model的id与它冲突，你可以覆盖它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    cidPrefix: <span class="hljs-string">'c'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-60">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-60">&#182;</a>
              </div>
              <p>Initialize默认是空函数。可以用你自己的初始化逻辑覆盖它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},</pre></div></div>
            
        </li>
        
        
        <li id="section-61">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-61">&#182;</a>
              </div>
              <p>返回model的<code>attributes</code>对象的拷贝。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">return</span> _.clone(<span class="hljs-keyword">this</span>.attributes);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-62">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-62">&#182;</a>
              </div>
              <p>默认代理<code>Backbone.sync</code> – 但如果你需要为当前<strong>这个</strong>特殊的model自定义同步语义，可以覆盖它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sync: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> Backbone.sync.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-63">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-63">&#182;</a>
              </div>
              <p>返回一个属性的值。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.attributes[attr];
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-64">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-64">&#182;</a>
              </div>
              <p>返回属性值的HTML转义后的值。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-built_in">escape</span>: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
      <span class="hljs-keyword">return</span> _.escape(<span class="hljs-keyword">this</span>.get(attr));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-65">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-65">&#182;</a>
              </div>
              <p>如果属性的值不是null或undefined，则返回<code>true</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    has: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(attr) != <span class="hljs-literal">null</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-66">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-66">&#182;</a>
              </div>
              <p>underscore的<code>_.matches</code>的特殊代理。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    matches: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) </span>{
      <span class="hljs-keyword">return</span> !!_.iteratee(attrs, <span class="hljs-keyword">this</span>)(<span class="hljs-keyword">this</span>.attributes);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-67">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-67">&#182;</a>
              </div>
              <p>设置model的属性，并触发<code>&quot;change&quot;</code>事件。这是model的核心操作，更新数据，
通知想要知道状态变更的对象。这是model的核心。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, val, options</span>) </span>{
      <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-68">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-68">&#182;</a>
              </div>
              <p>同时处理<code>&quot;key&quot;, value</code> 和 <code>{key: value}</code>风格的参数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> attrs;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'object'</span>) {
        attrs = key;
        options = val;
      } <span class="hljs-keyword">else</span> {
        (attrs = {})[key] = val;
      }

      options || (options = {});</pre></div></div>
            
        </li>
        
        
        <li id="section-69">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-69">&#182;</a>
              </div>
              <p>执行校验。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._validate(attrs, options)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-70">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-70">&#182;</a>
              </div>
              <p>提取属性和选项。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> unset      = options.unset;
      <span class="hljs-keyword">var</span> silent     = options.silent;
      <span class="hljs-keyword">var</span> changes    = [];
      <span class="hljs-keyword">var</span> changing   = <span class="hljs-keyword">this</span>._changing;
      <span class="hljs-keyword">this</span>._changing = <span class="hljs-literal">true</span>;

      <span class="hljs-keyword">if</span> (!changing) {
        <span class="hljs-keyword">this</span>._previousAttributes = _.clone(<span class="hljs-keyword">this</span>.attributes);
        <span class="hljs-keyword">this</span>.changed = {};
      }

      <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span>.attributes;
      <span class="hljs-keyword">var</span> changed = <span class="hljs-keyword">this</span>.changed;
      <span class="hljs-keyword">var</span> prev    = <span class="hljs-keyword">this</span>._previousAttributes;</pre></div></div>
            
        </li>
        
        
        <li id="section-71">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-71">&#182;</a>
              </div>
              <p>对于每个要<code>设置</code>的属性，更新或删除当前值。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> attrs) {
        val = attrs[attr];
        <span class="hljs-keyword">if</span> (!_.isEqual(current[attr], val)) changes.push(attr);
        <span class="hljs-keyword">if</span> (!_.isEqual(prev[attr], val)) {
          changed[attr] = val;
        } <span class="hljs-keyword">else</span> {
          <span class="hljs-keyword">delete</span> changed[attr];
        }
        unset ? <span class="hljs-keyword">delete</span> current[attr] : current[attr] = val;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-72">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-72">&#182;</a>
              </div>
              <p>更新<code>id</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.idAttribute <span class="hljs-keyword">in</span> attrs) <span class="hljs-keyword">this</span>.id = <span class="hljs-keyword">this</span>.get(<span class="hljs-keyword">this</span>.idAttribute);</pre></div></div>
            
        </li>
        
        
        <li id="section-73">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-73">&#182;</a>
              </div>
              <p>触发所有相关属性的变更事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!silent) {
        <span class="hljs-keyword">if</span> (changes.length) <span class="hljs-keyword">this</span>._pending = options;
        <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; changes.length; i++) {
          <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'change:'</span> + changes[i], <span class="hljs-keyword">this</span>, current[changes[i]], options);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-74">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-74">&#182;</a>
              </div>
              <p>可能你会迷惑为什么这里有个<code>while</code>循环。<code>&quot;change&quot;</code>事件可能引起嵌套的变更。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (changing) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">if</span> (!silent) {
        <span class="hljs-keyword">while</span> (<span class="hljs-keyword">this</span>._pending) {
          options = <span class="hljs-keyword">this</span>._pending;
          <span class="hljs-keyword">this</span>._pending = <span class="hljs-literal">false</span>;
          <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'change'</span>, <span class="hljs-keyword">this</span>, options);
        }
      }
      <span class="hljs-keyword">this</span>._pending = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>._changing = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-75">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-75">&#182;</a>
              </div>
              <p>从model中删除一个属性，触发<code>&quot;change&quot;</code>事件。如属性不存在，<code>unset</code>会是空操作。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    unset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr, options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.set(attr, <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>, _.extend({}, options, {<span class="hljs-attr">unset</span>: <span class="hljs-literal">true</span>}));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-76">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-76">&#182;</a>
              </div>
              <p>清除model上的所有属性，触发<code>&quot;change&quot;</code>事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clear: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> attrs = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> <span class="hljs-keyword">this</span>.attributes) attrs[key] = <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.set(attrs, _.extend({}, options, {<span class="hljs-attr">unset</span>: <span class="hljs-literal">true</span>}));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-77">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-77">&#182;</a>
              </div>
              <p>判断model自从上次的<code>&quot;change&quot;</code>事件以来是否发生了变化。
如果给定一个属性名称，会判断是否此属性发生了变化。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    hasChanged: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
      <span class="hljs-keyword">if</span> (attr == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> !_.isEmpty(<span class="hljs-keyword">this</span>.changed);
      <span class="hljs-keyword">return</span> _.has(<span class="hljs-keyword">this</span>.changed, attr);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-78">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-78">&#182;</a>
              </div>
              <p>返回一个对象，包含所有已经变更的属性，如果属性没有变更那么返回值为false。有益于用来决定一个视图
是否需要更新，或属性是否需要持久化到服务器端。复位的属性会被设置为undefined。
你可以传入一个属性对象与model做差异比较，决定是否有变更发生。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    changedAttributes: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">diff</span>) </span>{
      <span class="hljs-keyword">if</span> (!diff) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.hasChanged() ? _.clone(<span class="hljs-keyword">this</span>.changed) : <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> old = <span class="hljs-keyword">this</span>._changing ? <span class="hljs-keyword">this</span>._previousAttributes : <span class="hljs-keyword">this</span>.attributes;
      <span class="hljs-keyword">var</span> changed = {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> attr <span class="hljs-keyword">in</span> diff) {
        <span class="hljs-keyword">var</span> val = diff[attr];
        <span class="hljs-keyword">if</span> (_.isEqual(old[attr], val)) <span class="hljs-keyword">continue</span>;
        changed[attr] = val;
      }
      <span class="hljs-keyword">return</span> _.size(changed) ? changed : <span class="hljs-literal">false</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-79">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-79">&#182;</a>
              </div>
              <p>获取之前属性的值，在上次<code>&quot;change&quot;</code>事件变更后记录的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    previous: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
      <span class="hljs-keyword">if</span> (attr == <span class="hljs-literal">null</span> || !<span class="hljs-keyword">this</span>._previousAttributes) <span class="hljs-keyword">return</span> <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._previousAttributes[attr];
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-80">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-80">&#182;</a>
              </div>
              <p>获取上次<code>&quot;change&quot;</code>事件发生后的，所有model的属性，</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    previousAttributes: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> _.clone(<span class="hljs-keyword">this</span>._previousAttributes);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-81">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-81">&#182;</a>
              </div>
              <p>从服务器端拉取molde的数据，将响应同model的本地属性进行合并。任何变更的属性都会触发一个”change” 事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      options = _.extend({<span class="hljs-attr">parse</span>: <span class="hljs-literal">true</span>}, options);
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> success = options.success;
      options.success = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{
        <span class="hljs-keyword">var</span> serverAttrs = options.parse ? model.parse(resp, options) : resp;
        <span class="hljs-keyword">if</span> (!model.set(serverAttrs, options)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (success) success.call(options.context, model, resp, options);
        model.trigger(<span class="hljs-string">'sync'</span>, model, resp, options);
      };
      wrapError(<span class="hljs-keyword">this</span>, options);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sync(<span class="hljs-string">'read'</span>, <span class="hljs-keyword">this</span>, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-82">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-82">&#182;</a>
              </div>
              <p>设置model的属性，将model同步到服务器端。如果服务器返回一个不同的属性的hash，会重新设置model的状态。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    save: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">key, val, options</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-83">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-83">&#182;</a>
              </div>
              <p>同时处理<code>&quot;key&quot;, value</code> 和 <code>{key: value}</code>风格的参数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> attrs;
      <span class="hljs-keyword">if</span> (key == <span class="hljs-literal">null</span> || <span class="hljs-keyword">typeof</span> key === <span class="hljs-string">'object'</span>) {
        attrs = key;
        options = val;
      } <span class="hljs-keyword">else</span> {
        (attrs = {})[key] = val;
      }

      options = _.extend({<span class="hljs-attr">validate</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">parse</span>: <span class="hljs-literal">true</span>}, options);
      <span class="hljs-keyword">var</span> wait = options.wait;</pre></div></div>
            
        </li>
        
        
        <li id="section-84">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-84">&#182;</a>
              </div>
              <p>如果我们在等待，且属性已存在，save操作等价于带校验的<code>set(attr).save(null, opts)</code>。否则，
检测在设置属性时，需要检查model是否是合法的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (attrs &amp;&amp; !wait) {
        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.set(attrs, options)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._validate(attrs, options)) {
        <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-85">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-85">&#182;</a>
              </div>
              <p>在成功保存到服务器端后，客户端需要更新到服务器端的状态（可选的）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> success = options.success;
      <span class="hljs-keyword">var</span> attributes = <span class="hljs-keyword">this</span>.attributes;
      options.success = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-86">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-86">&#182;</a>
              </div>
              <p>保证在同步保存过程中存储属性。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        model.attributes = attributes;
        <span class="hljs-keyword">var</span> serverAttrs = options.parse ? model.parse(resp, options) : resp;
        <span class="hljs-keyword">if</span> (wait) serverAttrs = _.extend({}, attrs, serverAttrs);
        <span class="hljs-keyword">if</span> (serverAttrs &amp;&amp; !model.set(serverAttrs, options)) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
        <span class="hljs-keyword">if</span> (success) success.call(options.context, model, resp, options);
        model.trigger(<span class="hljs-string">'sync'</span>, model, resp, options);
      };
      wrapError(<span class="hljs-keyword">this</span>, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-87">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-87">&#182;</a>
              </div>
              <p>如果<code>{wait: true}</code>，就设置临时属性来寻找新的ids。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (attrs &amp;&amp; wait) <span class="hljs-keyword">this</span>.attributes = _.extend({}, attributes, attrs);

      <span class="hljs-keyword">var</span> method = <span class="hljs-keyword">this</span>.isNew() ? <span class="hljs-string">'create'</span> : (options.patch ? <span class="hljs-string">'patch'</span> : <span class="hljs-string">'update'</span>);
      <span class="hljs-keyword">if</span> (method === <span class="hljs-string">'patch'</span> &amp;&amp; !options.attrs) options.attrs = attrs;
      <span class="hljs-keyword">var</span> xhr = <span class="hljs-keyword">this</span>.sync(method, <span class="hljs-keyword">this</span>, options);</pre></div></div>
            
        </li>
        
        
        <li id="section-88">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-88">&#182;</a>
              </div>
              <p>恢复属性。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.attributes = attributes;

      <span class="hljs-keyword">return</span> xhr;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-89">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-89">&#182;</a>
              </div>
              <p>如果model已经持久化了，那么就在服务器端销毁它。
如果modelc存在于collection中，那么就把他移除掉。
如果传入<code>wait: true</code>，要等到服务器相应后再销毁model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    destroy: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      options = options ? _.clone(options) : {};
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> success = options.success;
      <span class="hljs-keyword">var</span> wait = options.wait;

      <span class="hljs-keyword">var</span> destroy = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
        model.stopListening();
        model.trigger(<span class="hljs-string">'destroy'</span>, model, model.collection, options);
      };

      options.success = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{
        <span class="hljs-keyword">if</span> (wait) destroy();
        <span class="hljs-keyword">if</span> (success) success.call(options.context, model, resp, options);
        <span class="hljs-keyword">if</span> (!model.isNew()) model.trigger(<span class="hljs-string">'sync'</span>, model, resp, options);
      };

      <span class="hljs-keyword">var</span> xhr = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isNew()) {
        _.defer(options.success);
      } <span class="hljs-keyword">else</span> {
        wrapError(<span class="hljs-keyword">this</span>, options);
        xhr = <span class="hljs-keyword">this</span>.sync(<span class="hljs-string">'delete'</span>, <span class="hljs-keyword">this</span>, options);
      }
      <span class="hljs-keyword">if</span> (!wait) destroy();
      <span class="hljs-keyword">return</span> xhr;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-90">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-90">&#182;</a>
              </div>
              <p>model在服务器端的默认的URL - 如果你正在使用Backbone的restful方法，可以覆盖当前方法来改变调用终点。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    url: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> base =
        _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'urlRoot'</span>) ||
        _.result(<span class="hljs-keyword">this</span>.collection, <span class="hljs-string">'url'</span>) ||
        urlError();
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.isNew()) <span class="hljs-keyword">return</span> base;
      <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.get(<span class="hljs-keyword">this</span>.idAttribute);
      <span class="hljs-keyword">return</span> base.replace(<span class="hljs-regexp">/[^\/]$/</span>, <span class="hljs-string">'$&amp;/'</span>) + <span class="hljs-built_in">encodeURIComponent</span>(id);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-91">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-91">&#182;</a>
              </div>
              <p><strong>parse</strong>将response转换为一个属性的hash，用来<code>set</code>到model上。默认只会直接返回response。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    parse: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp, options</span>) </span>{
      <span class="hljs-keyword">return</span> resp;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-92">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-92">&#182;</a>
              </div>
              <p>使用当前model的属性，创建一个新的model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clone: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor(<span class="hljs-keyword">this</span>.attributes);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-93">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-93">&#182;</a>
              </div>
              <p>如果model没有保存到服务器，并且缺少一个id，那么model就是新的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isNew: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> !<span class="hljs-keyword">this</span>.has(<span class="hljs-keyword">this</span>.idAttribute);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-94">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-94">&#182;</a>
              </div>
              <p>检查model当前是否是有效状态。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    isValid: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._validate({}, _.extend({}, options, {<span class="hljs-attr">validate</span>: <span class="hljs-literal">true</span>}));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-95">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-95">&#182;</a>
              </div>
              <p>在设置model属性之前执行校验，如果校验通过，返回<code>true</code>。否则触发一个<code>&quot;invalid&quot;</code>事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _validate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs, options</span>) </span>{
      <span class="hljs-keyword">if</span> (!options.validate || !<span class="hljs-keyword">this</span>.validate) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      attrs = _.extend({}, <span class="hljs-keyword">this</span>.attributes, attrs);
      <span class="hljs-keyword">var</span> error = <span class="hljs-keyword">this</span>.validationError = <span class="hljs-keyword">this</span>.validate(attrs, options) || <span class="hljs-literal">null</span>;
      <span class="hljs-keyword">if</span> (!error) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'invalid'</span>, <span class="hljs-keyword">this</span>, error, _.extend(options, {<span class="hljs-attr">validationError</span>: error}));
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-96">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-96">&#182;</a>
              </div>
              <p>我们希望Model实现的Underscore的方法，这里是一个每个方法接受参数个数的映射。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> modelMethods = {<span class="hljs-attr">keys</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">values</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">pairs</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">invert</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">pick</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">omit</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">chain</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">isEmpty</span>: <span class="hljs-number">1</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-97">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-97">&#182;</a>
              </div>
              <p>以<code>Model#attributes</code>代理的形式，混入Underscore的每个方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  addUnderscoreMethods(Model, modelMethods, <span class="hljs-string">'attributes'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-98">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-98">&#182;</a>
              </div>
              <h2 id="-backbone-collection">集合 - Backbone.Collection</h2>

            </div>
            
        </li>
        
        
        <li id="section-99">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-99">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-100">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-100">&#182;</a>
              </div>
              <p>如果model代表了一行数据，那么Backbone的Collection则更像是数据表…或表的一部分或一页，
或者是因为特定原因而聚集在一起的一组行 - 比如，在特定目录下的所有消息，属于特定作者的所有文档，等等。
Collection维护了它们model的索引，它们都是有序的，并且可以根据<code>id</code>进行查找。</p>
<p>创建一个新的 <strong>Collection</strong>，可能会包含了给定类型的<code>model</code>。如果指定了一个<code>comparator</code>，当新增或移除model时，Collection会
维护model顺序。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> Collection = Backbone.Collection = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, options</span>) </span>{
    options || (options = {});
    <span class="hljs-keyword">if</span> (options.model) <span class="hljs-keyword">this</span>.model = options.model;
    <span class="hljs-keyword">if</span> (options.comparator !== <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>) <span class="hljs-keyword">this</span>.comparator = options.comparator;
    <span class="hljs-keyword">this</span>._reset();
    <span class="hljs-keyword">this</span>.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    <span class="hljs-keyword">if</span> (models) <span class="hljs-keyword">this</span>.reset(models, _.extend({<span class="hljs-attr">silent</span>: <span class="hljs-literal">true</span>}, options));
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-101">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-101">&#182;</a>
              </div>
              <p><code>Collection#set</code>的默认选项.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> setOptions = {<span class="hljs-attr">add</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">remove</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">merge</span>: <span class="hljs-literal">true</span>};
  <span class="hljs-keyword">var</span> addOptions = {<span class="hljs-attr">add</span>: <span class="hljs-literal">true</span>, <span class="hljs-attr">remove</span>: <span class="hljs-literal">false</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-102">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-102">&#182;</a>
              </div>
              <p>在<code>at</code>指定的索引处，插入元素到数组中</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> splice = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">array, insert, at</span>) </span>{
    at = <span class="hljs-built_in">Math</span>.min(<span class="hljs-built_in">Math</span>.max(at, <span class="hljs-number">0</span>), array.length);
    <span class="hljs-keyword">var</span> tail = <span class="hljs-built_in">Array</span>(array.length - at);
    <span class="hljs-keyword">var</span> length = insert.length;
    <span class="hljs-keyword">var</span> i;
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tail.length; i++) tail[i] = array[i + at];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; length; i++) array[i + at] = insert[i];
    <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; tail.length; i++) array[i + length + at] = tail[i];
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-103">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-103">&#182;</a>
              </div>
              <p>定义Collection的可继承方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Collection.prototype, Events, {</pre></div></div>
            
        </li>
        
        
        <li id="section-104">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-104">&#182;</a>
              </div>
              <p>集合默认的model类型仅仅是一个<strong>Backbone.Model</strong>。
多数情况下会覆盖掉它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    model: Model,</pre></div></div>
            
        </li>
        
        
        <li id="section-105">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-105">&#182;</a>
              </div>
              <p>初始化函数默认是个空函数。用以自己的初始化逻辑覆盖它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},</pre></div></div>
            
        </li>
        
        
        <li id="section-106">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-106">&#182;</a>
              </div>
              <p>一个集合JSON的表示是由models的属性组成的一个数组。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    toJSON: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map(<span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{ <span class="hljs-keyword">return</span> model.toJSON(options); });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-107">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-107">&#182;</a>
              </div>
              <p>默认代理<code>Backbone.sync</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sync: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> Backbone.sync.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-108">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-108">&#182;</a>
              </div>
              <p>添加一个model，或一个model的列表。<code>models</code>可以是Backbone的Models或JavaScript的原始对象，
此对象可以转换为Models，或这两种类型的结合。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    add: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.set(models, _.extend({<span class="hljs-attr">merge</span>: <span class="hljs-literal">false</span>}, options, addOptions));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-109">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-109">&#182;</a>
              </div>
              <p>删除一个model，或一个model的列表。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, options</span>) </span>{
      options = _.extend({}, options);
      <span class="hljs-keyword">var</span> singular = !_.isArray(models);
      models = singular ? [models] : models.slice();
      <span class="hljs-keyword">var</span> removed = <span class="hljs-keyword">this</span>._removeModels(models, options);
      <span class="hljs-keyword">if</span> (!options.silent &amp;&amp; removed.length) {
        options.changes = {<span class="hljs-attr">added</span>: [], <span class="hljs-attr">merged</span>: [], <span class="hljs-attr">removed</span>: removed};
        <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'update'</span>, <span class="hljs-keyword">this</span>, options);
      }
      <span class="hljs-keyword">return</span> singular ? removed[<span class="hljs-number">0</span>] : removed;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-110">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-110">&#182;</a>
              </div>
              <p>通过设置一个新的model列表来更新一个collection，按需添加新的，删除不存在的，合并collection中
已存在的。类似于<strong>Model#set</strong>，是用来更新collection中数据的核心操作。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    set: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, options</span>) </span>{
      <span class="hljs-keyword">if</span> (models == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span>;

      options = _.extend({}, setOptions, options);
      <span class="hljs-keyword">if</span> (options.parse &amp;&amp; !<span class="hljs-keyword">this</span>._isModel(models)) {
        models = <span class="hljs-keyword">this</span>.parse(models, options) || [];
      }

      <span class="hljs-keyword">var</span> singular = !_.isArray(models);
      models = singular ? [models] : models.slice();

      <span class="hljs-keyword">var</span> at = options.at;
      <span class="hljs-keyword">if</span> (at != <span class="hljs-literal">null</span>) at = +at;
      <span class="hljs-keyword">if</span> (at &gt; <span class="hljs-keyword">this</span>.length) at = <span class="hljs-keyword">this</span>.length;
      <span class="hljs-keyword">if</span> (at &lt; <span class="hljs-number">0</span>) at += <span class="hljs-keyword">this</span>.length + <span class="hljs-number">1</span>;

      <span class="hljs-keyword">var</span> set = [];
      <span class="hljs-keyword">var</span> toAdd = [];
      <span class="hljs-keyword">var</span> toMerge = [];
      <span class="hljs-keyword">var</span> toRemove = [];
      <span class="hljs-keyword">var</span> modelMap = {};

      <span class="hljs-keyword">var</span> add = options.add;
      <span class="hljs-keyword">var</span> merge = options.merge;
      <span class="hljs-keyword">var</span> remove = options.remove;

      <span class="hljs-keyword">var</span> sort = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> sortable = <span class="hljs-keyword">this</span>.comparator &amp;&amp; at == <span class="hljs-literal">null</span> &amp;&amp; options.sort !== <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> sortAttr = _.isString(<span class="hljs-keyword">this</span>.comparator) ? <span class="hljs-keyword">this</span>.comparator : <span class="hljs-literal">null</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-111">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-111">&#182;</a>
              </div>
              <p>将裸对象转换为model的引用，阻止添加不合法的model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> model, i;
      <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; models.length; i++) {
        model = models[i];</pre></div></div>
            
        </li>
        
        
        <li id="section-112">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-112">&#182;</a>
              </div>
              <p>如果发现了一个重复的model，就不在添加新的了，而是选择性的将它合并到这个已存在的model上。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> existing = <span class="hljs-keyword">this</span>.get(model);
        <span class="hljs-keyword">if</span> (existing) {
          <span class="hljs-keyword">if</span> (merge &amp;&amp; model !== existing) {
            <span class="hljs-keyword">var</span> attrs = <span class="hljs-keyword">this</span>._isModel(model) ? model.attributes : model;
            <span class="hljs-keyword">if</span> (options.parse) attrs = existing.parse(attrs, options);
            existing.set(attrs, options);
            toMerge.push(existing);
            <span class="hljs-keyword">if</span> (sortable &amp;&amp; !sort) sort = existing.hasChanged(sortAttr);
          }
          <span class="hljs-keyword">if</span> (!modelMap[existing.cid]) {
            modelMap[existing.cid] = <span class="hljs-literal">true</span>;
            set.push(existing);
          }
          models[i] = existing;</pre></div></div>
            
        </li>
        
        
        <li id="section-113">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-113">&#182;</a>
              </div>
              <p>如果是一个新的合法的model，就将它push到<code>toAdd</code>列表中去。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (add) {
          model = models[i] = <span class="hljs-keyword">this</span>._prepareModel(model, options);
          <span class="hljs-keyword">if</span> (model) {
            toAdd.push(model);
            <span class="hljs-keyword">this</span>._addReference(model, options);
            modelMap[model.cid] = <span class="hljs-literal">true</span>;
            set.push(model);
          }
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-114">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-114">&#182;</a>
              </div>
              <p>删除就的models。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (remove) {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.length; i++) {
          model = <span class="hljs-keyword">this</span>.models[i];
          <span class="hljs-keyword">if</span> (!modelMap[model.cid]) toRemove.push(model);
        }
        <span class="hljs-keyword">if</span> (toRemove.length) <span class="hljs-keyword">this</span>._removeModels(toRemove, options);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-115">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-115">&#182;</a>
              </div>
              <p>查看是否需要排序，更新<code>length</code> 属性，插入新的models。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> orderChanged = <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">var</span> replace = !sortable &amp;&amp; add &amp;&amp; remove;
      <span class="hljs-keyword">if</span> (set.length &amp;&amp; replace) {
        orderChanged = <span class="hljs-keyword">this</span>.length !== set.length || _.some(<span class="hljs-keyword">this</span>.models, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, index</span>) </span>{
          <span class="hljs-keyword">return</span> m !== set[index];
        });
        <span class="hljs-keyword">this</span>.models.length = <span class="hljs-number">0</span>;
        splice(<span class="hljs-keyword">this</span>.models, set, <span class="hljs-number">0</span>);
        <span class="hljs-keyword">this</span>.length = <span class="hljs-keyword">this</span>.models.length;
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (toAdd.length) {
        <span class="hljs-keyword">if</span> (sortable) sort = <span class="hljs-literal">true</span>;
        splice(<span class="hljs-keyword">this</span>.models, toAdd, at == <span class="hljs-literal">null</span> ? <span class="hljs-keyword">this</span>.length : at);
        <span class="hljs-keyword">this</span>.length = <span class="hljs-keyword">this</span>.models.length;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-116">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-116">&#182;</a>
              </div>
              <p>如何合适的话，无声的将collection排序。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (sort) <span class="hljs-keyword">this</span>.sort({<span class="hljs-attr">silent</span>: <span class="hljs-literal">true</span>});</pre></div></div>
            
        </li>
        
        
        <li id="section-117">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-117">&#182;</a>
              </div>
              <p>如果不是无声的更新，是时候触发所有合适的add/sort/update事件了。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!options.silent) {
        <span class="hljs-keyword">for</span> (i = <span class="hljs-number">0</span>; i &lt; toAdd.length; i++) {
          <span class="hljs-keyword">if</span> (at != <span class="hljs-literal">null</span>) options.index = at + i;
          model = toAdd[i];
          model.trigger(<span class="hljs-string">'add'</span>, model, <span class="hljs-keyword">this</span>, options);
        }
        <span class="hljs-keyword">if</span> (sort || orderChanged) <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'sort'</span>, <span class="hljs-keyword">this</span>, options);
        <span class="hljs-keyword">if</span> (toAdd.length || toRemove.length || toMerge.length) {
          options.changes = {
            <span class="hljs-attr">added</span>: toAdd,
            <span class="hljs-attr">removed</span>: toRemove,
            <span class="hljs-attr">merged</span>: toMerge
          };
          <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'update'</span>, <span class="hljs-keyword">this</span>, options);
        }
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-118">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-118">&#182;</a>
              </div>
              <p>返回新增的（或合并后的）model（或models）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">return</span> singular ? models[<span class="hljs-number">0</span>] : models;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-119">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-119">&#182;</a>
              </div>
              <p>在你有许多需要单独添加或删除的元素时，你可以使用一个新的model列表重置整个集合，
这不会细粒度的触发<code>add</code>和<code>remove</code>事件。在重置完成后仅触发一个<code>resets</code>事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    reset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, options</span>) </span>{
      options = options ? _.clone(options) : {};
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; <span class="hljs-keyword">this</span>.models.length; i++) {
        <span class="hljs-keyword">this</span>._removeReference(<span class="hljs-keyword">this</span>.models[i], options);
      }
      options.previousModels = <span class="hljs-keyword">this</span>.models;
      <span class="hljs-keyword">this</span>._reset();
      models = <span class="hljs-keyword">this</span>.add(models, _.extend({<span class="hljs-attr">silent</span>: <span class="hljs-literal">true</span>}, options));
      <span class="hljs-keyword">if</span> (!options.silent) <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'reset'</span>, <span class="hljs-keyword">this</span>, options);
      <span class="hljs-keyword">return</span> models;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-120">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-120">&#182;</a>
              </div>
              <p>将一个model添加到collection的最后。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    push: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(model, _.extend({<span class="hljs-attr">at</span>: <span class="hljs-keyword">this</span>.length}, options));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-121">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-121">&#182;</a>
              </div>
              <p>移除collection最后一个model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    pop: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.at(<span class="hljs-keyword">this</span>.length - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(model, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-122">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-122">&#182;</a>
              </div>
              <p>在collection的开始出添加一个model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    unshift: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, options</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.add(model, _.extend({<span class="hljs-attr">at</span>: <span class="hljs-number">0</span>}, options));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-123">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-123">&#182;</a>
              </div>
              <p>移除collection的第一个model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    shift: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.at(<span class="hljs-number">0</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.remove(model, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-124">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-124">&#182;</a>
              </div>
              <p>从集合的模型中分割出一个子数组。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    slice: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> slice.apply(<span class="hljs-keyword">this</span>.models, <span class="hljs-built_in">arguments</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-125">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-125">&#182;</a>
              </div>
              <p>获得一个model，可以给定id，cid，也可以给定带有id或cid属性的model对象，同时还可以给定一个由modelId方法转换的属性对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    get: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">if</span> (obj == <span class="hljs-literal">null</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">void</span> <span class="hljs-number">0</span>;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>._byId[obj] ||
        <span class="hljs-keyword">this</span>._byId[<span class="hljs-keyword">this</span>.modelId(obj.attributes || obj)] ||
        obj.cid &amp;&amp; <span class="hljs-keyword">this</span>._byId[obj.cid];
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-126">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-126">&#182;</a>
              </div>
              <p>如果model在collection中，返回<code>True</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    has: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">obj</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.get(obj) != <span class="hljs-literal">null</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-127">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-127">&#182;</a>
              </div>
              <p>根据索引获取model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    at: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">index</span>) </span>{
      <span class="hljs-keyword">if</span> (index &lt; <span class="hljs-number">0</span>) index += <span class="hljs-keyword">this</span>.length;
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.models[index];
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-128">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-128">&#182;</a>
              </div>
              <p>返回与给定属性匹配的models。用来当做<code>filter</code>比较有用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    where: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs, first</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>[first ? <span class="hljs-string">'find'</span> : <span class="hljs-string">'filter'</span>](attrs);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-129">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-129">&#182;</a>
              </div>
              <p>返回第一个与给定属性匹配的model。用来当做<code>find</code>比较有用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    findWhere: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.where(attrs, <span class="hljs-literal">true</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-130">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-130">&#182;</a>
              </div>
              <p>强制collection重排序。通常情况下不需要调用此方法，因为在添加新的元素时set方法会维护它的顺序。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    sort: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">var</span> comparator = <span class="hljs-keyword">this</span>.comparator;
      <span class="hljs-keyword">if</span> (!comparator) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Cannot sort a set without a comparator'</span>);
      options || (options = {});

      <span class="hljs-keyword">var</span> length = comparator.length;
      <span class="hljs-keyword">if</span> (_.isFunction(comparator)) comparator = _.bind(comparator, <span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-131">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-131">&#182;</a>
              </div>
              <p>根据 <code>comparator</code>的类型排序。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (length === <span class="hljs-number">1</span> || _.isString(comparator)) {
        <span class="hljs-keyword">this</span>.models = <span class="hljs-keyword">this</span>.sortBy(comparator);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.models.sort(comparator);
      }
      <span class="hljs-keyword">if</span> (!options.silent) <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'sort'</span>, <span class="hljs-keyword">this</span>, options);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-132">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-132">&#182;</a>
              </div>
              <p>从集合中的每个模型中获取一个属性。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    pluck: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attr</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.map(attr + <span class="hljs-string">''</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-133">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-133">&#182;</a>
              </div>
              <p>为collection抓取默认的model的集合，在数据返回后重置collection。如果传入<code>reset: true</code>，
响应数据会传入<code>reset</code>方法而不是<code>set</code>方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    fetch: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      options = _.extend({<span class="hljs-attr">parse</span>: <span class="hljs-literal">true</span>}, options);
      <span class="hljs-keyword">var</span> success = options.success;
      <span class="hljs-keyword">var</span> collection = <span class="hljs-keyword">this</span>;
      options.success = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{
        <span class="hljs-keyword">var</span> method = options.reset ? <span class="hljs-string">'reset'</span> : <span class="hljs-string">'set'</span>;
        collection[method](resp, options);
        <span class="hljs-keyword">if</span> (success) success.call(options.context, collection, resp, options);
        collection.trigger(<span class="hljs-string">'sync'</span>, collection, resp, options);
      };
      wrapError(<span class="hljs-keyword">this</span>, options);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.sync(<span class="hljs-string">'read'</span>, <span class="hljs-keyword">this</span>, options);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-134">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-134">&#182;</a>
              </div>
              <p>在collection中创建一个新的model实例。除非传入<code>wait: true</code>以等待服务器响应，
否则model会马上添加到collection中，</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    create: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, options</span>) </span>{
      options = options ? _.clone(options) : {};
      <span class="hljs-keyword">var</span> wait = options.wait;
      model = <span class="hljs-keyword">this</span>._prepareModel(model, options);
      <span class="hljs-keyword">if</span> (!model) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (!wait) <span class="hljs-keyword">this</span>.add(model, options);
      <span class="hljs-keyword">var</span> collection = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> success = options.success;
      options.success = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">m, resp, callbackOpts</span>) </span>{
        <span class="hljs-keyword">if</span> (wait) collection.add(m, callbackOpts);
        <span class="hljs-keyword">if</span> (success) success.call(callbackOpts.context, m, resp, callbackOpts);
      };
      model.save(<span class="hljs-literal">null</span>, options);
      <span class="hljs-keyword">return</span> model;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-135">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-135">&#182;</a>
              </div>
              <p><strong>parse</strong>将一个服务器的响应（response）转换为一个model的列表，之后加入collection。
默认实现是直接返回response。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    parse: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp, options</span>) </span>{
      <span class="hljs-keyword">return</span> resp;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-136">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-136">&#182;</a>
              </div>
              <p>创建一个新集合，与当前集合的model列表相同。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    clone: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.constructor(<span class="hljs-keyword">this</span>.models, {
        <span class="hljs-attr">model</span>: <span class="hljs-keyword">this</span>.model,
        <span class="hljs-attr">comparator</span>: <span class="hljs-keyword">this</span>.comparator
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-137">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-137">&#182;</a>
              </div>
              <p>定义在collection中如何唯一标识一个model。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    modelId: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs</span>) </span>{
      <span class="hljs-keyword">return</span> attrs[<span class="hljs-keyword">this</span>.model.prototype.idAttribute || <span class="hljs-string">'id'</span>];
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-138">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-138">&#182;</a>
              </div>
              <p>私有方法，用来重置所有内部状态。collection首次初始化或重置时调用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _reset: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.length = <span class="hljs-number">0</span>;
      <span class="hljs-keyword">this</span>.models = [];
      <span class="hljs-keyword">this</span>._byId  = {};
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-139">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-139">&#182;</a>
              </div>
              <p>准备将一个属性的hash(或别的model)加入到collection中。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _prepareModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attrs, options</span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._isModel(attrs)) {
        <span class="hljs-keyword">if</span> (!attrs.collection) attrs.collection = <span class="hljs-keyword">this</span>;
        <span class="hljs-keyword">return</span> attrs;
      }
      options = options ? _.clone(options) : {};
      options.collection = <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">new</span> <span class="hljs-keyword">this</span>.model(attrs, options);
      <span class="hljs-keyword">if</span> (!model.validationError) <span class="hljs-keyword">return</span> model;
      <span class="hljs-keyword">this</span>.trigger(<span class="hljs-string">'invalid'</span>, <span class="hljs-keyword">this</span>, model.validationError, options);
      <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-140">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-140">&#182;</a>
              </div>
              <p>内部方法，供remove和set方法调用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _removeModels: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">models, options</span>) </span>{
      <span class="hljs-keyword">var</span> removed = [];
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> i = <span class="hljs-number">0</span>; i &lt; models.length; i++) {
        <span class="hljs-keyword">var</span> model = <span class="hljs-keyword">this</span>.get(models[i]);
        <span class="hljs-keyword">if</span> (!model) <span class="hljs-keyword">continue</span>;

        <span class="hljs-keyword">var</span> index = <span class="hljs-keyword">this</span>.indexOf(model);
        <span class="hljs-keyword">this</span>.models.splice(index, <span class="hljs-number">1</span>);
        <span class="hljs-keyword">this</span>.length--;</pre></div></div>
            
        </li>
        
        
        <li id="section-141">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-141">&#182;</a>
              </div>
              <p>在触发 ‘remove’ 事件前，移除引用，防止死循环。#3693</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._byId[model.cid];
        <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.modelId(model.attributes);
        <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._byId[id];

        <span class="hljs-keyword">if</span> (!options.silent) {
          options.index = index;
          model.trigger(<span class="hljs-string">'remove'</span>, model, <span class="hljs-keyword">this</span>, options);
        }

        removed.push(model);
        <span class="hljs-keyword">this</span>._removeReference(model, options);
      }
      <span class="hljs-keyword">return</span> removed;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-142">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-142">&#182;</a>
              </div>
              <p>用来检查一个对象是否是Model类型，用来添加到collection中。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _isModel: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model</span>) </span>{
      <span class="hljs-keyword">return</span> model <span class="hljs-keyword">instanceof</span> Model;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-143">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-143">&#182;</a>
              </div>
              <p>内部方法，用来关联model与collection。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _addReference: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, options</span>) </span>{
      <span class="hljs-keyword">this</span>._byId[model.cid] = model;
      <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.modelId(model.attributes);
      <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) <span class="hljs-keyword">this</span>._byId[id] = model;
      model.on(<span class="hljs-string">'all'</span>, <span class="hljs-keyword">this</span>._onModelEvent, <span class="hljs-keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-144">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-144">&#182;</a>
              </div>
              <p>内部方法，用来切断model与collection的关联。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _removeReference: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, options</span>) </span>{
      <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._byId[model.cid];
      <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.modelId(model.attributes);
      <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._byId[id];
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> === model.collection) <span class="hljs-keyword">delete</span> model.collection;
      model.off(<span class="hljs-string">'all'</span>, <span class="hljs-keyword">this</span>._onModelEvent, <span class="hljs-keyword">this</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-145">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-145">&#182;</a>
              </div>
              <p>内部方法，每次set方法中的model触发事件时都会调用。在model改变id后，集合中的元素会更新索引。
所有其它的事件都是代理的此方法。会忽略其它集合中触发的“add”和“remove”事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _onModelEvent: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">event, model, collection, options</span>) </span>{
      <span class="hljs-keyword">if</span> (model) {
        <span class="hljs-keyword">if</span> ((event === <span class="hljs-string">'add'</span> || event === <span class="hljs-string">'remove'</span>) &amp;&amp; collection !== <span class="hljs-keyword">this</span>) <span class="hljs-keyword">return</span>;
        <span class="hljs-keyword">if</span> (event === <span class="hljs-string">'destroy'</span>) <span class="hljs-keyword">this</span>.remove(model, options);
        <span class="hljs-keyword">if</span> (event === <span class="hljs-string">'change'</span>) {
          <span class="hljs-keyword">var</span> prevId = <span class="hljs-keyword">this</span>.modelId(model.previousAttributes());
          <span class="hljs-keyword">var</span> id = <span class="hljs-keyword">this</span>.modelId(model.attributes);
          <span class="hljs-keyword">if</span> (prevId !== id) {
            <span class="hljs-keyword">if</span> (prevId != <span class="hljs-literal">null</span>) <span class="hljs-keyword">delete</span> <span class="hljs-keyword">this</span>._byId[prevId];
            <span class="hljs-keyword">if</span> (id != <span class="hljs-literal">null</span>) <span class="hljs-keyword">this</span>._byId[id] = model;
          }
        }
      }
      <span class="hljs-keyword">this</span>.trigger.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-146">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-146">&#182;</a>
              </div>
              <p>在Collection中我们需要实现的Underscore的方法。Backbone Collections中9%的个性方法事实上都是在这实现的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> collectionMethods = {<span class="hljs-attr">forEach</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">each</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">map</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">collect</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">reduce</span>: <span class="hljs-number">0</span>,
      <span class="hljs-attr">foldl</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">inject</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">reduceRight</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">foldr</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">find</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">detect</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">filter</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">select</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">reject</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">every</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">all</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">some</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">any</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">include</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">includes</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">contains</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">invoke</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">max</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">min</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">toArray</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">size</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">first</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">head</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">take</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">initial</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">rest</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">tail</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">drop</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">last</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">without</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">difference</span>: <span class="hljs-number">0</span>, <span class="hljs-attr">indexOf</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">shuffle</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">lastIndexOf</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">isEmpty</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">chain</span>: <span class="hljs-number">1</span>, <span class="hljs-attr">sample</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">partition</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">groupBy</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">countBy</span>: <span class="hljs-number">3</span>,
      <span class="hljs-attr">sortBy</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">indexBy</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">findIndex</span>: <span class="hljs-number">3</span>, <span class="hljs-attr">findLastIndex</span>: <span class="hljs-number">3</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-147">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-147">&#182;</a>
              </div>
              <p>混入每个Underscore的方法，作为<code>Collection#models</code>的代理。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  addUnderscoreMethods(Collection, collectionMethods, <span class="hljs-string">'models'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-148">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-148">&#182;</a>
              </div>
              <h2 id="-backbone-view">试图 - Backbone.View</h2>

            </div>
            
        </li>
        
        
        <li id="section-149">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-149">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-150">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-150">&#182;</a>
              </div>
              <p>Backbone的视图比起它们的代码来，更加约定俗称化。一个视图就是一个简单的JavaScript对象，它代表了
DOM中的一块带有逻辑的UI。可能是单个条目，一整个列表，一个侧栏或面板，更或者是囊括你整个应用的周围的框架。
将一块UI定义为一个<strong>View</strong>，允许你以声明式方式定义DOM的事件，而不用担心渲染次序…让视图能够更容易通过特殊的
事件来响应model状态的变化。</p>

            </div>
            
        </li>
        
        
        <li id="section-151">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-151">&#182;</a>
              </div>
              <p>创建一个Backbone.View，如果未提供一个已存在的元素，那么它会在DOM之外创建它的初始化元素。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> View = Backbone.View = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
    <span class="hljs-keyword">this</span>.cid = _.uniqueId(<span class="hljs-string">'view'</span>);
    _.extend(<span class="hljs-keyword">this</span>, _.pick(options, viewOptions));
    <span class="hljs-keyword">this</span>._ensureElement();
    <span class="hljs-keyword">this</span>.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-152">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-152">&#182;</a>
              </div>
              <p>缓存的正则表达式，用来分割<code>delegate</code>的关键字。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> delegateEventSplitter = <span class="hljs-regexp">/^(\S+)\s*(.*)$/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-153">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-153">&#182;</a>
              </div>
              <p>view的选项列表，用来当做属性设置。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> viewOptions = [<span class="hljs-string">'model'</span>, <span class="hljs-string">'collection'</span>, <span class="hljs-string">'el'</span>, <span class="hljs-string">'id'</span>, <span class="hljs-string">'attributes'</span>, <span class="hljs-string">'className'</span>, <span class="hljs-string">'tagName'</span>, <span class="hljs-string">'events'</span>];</pre></div></div>
            
        </li>
        
        
        <li id="section-154">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-154">&#182;</a>
              </div>
              <p>设置所有可继承的 <strong>Backbone.View</strong>的属性和方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(View.prototype, Events, {</pre></div></div>
            
        </li>
        
        
        <li id="section-155">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-155">&#182;</a>
              </div>
              <p>View的element的默认<code>tagName</code>是<code>&quot;div&quot;</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    tagName: <span class="hljs-string">'div'</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-156">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-156">&#182;</a>
              </div>
              <p>jQuery的代理，用来在当前视图包含的DOM元素中查找元素。比起全局查找来，这种方式更优。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    $: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">selector</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.$el.find(selector);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-157">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-157">&#182;</a>
              </div>
              <p>Initialize默认是个空函数。用你自己的初始化逻辑覆盖它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},</pre></div></div>
            
        </li>
        
        
        <li id="section-158">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-158">&#182;</a>
              </div>
              <p><strong>render</strong>是view应该覆盖的核心函数，为的是向它的元素(<code>this.el</code>)填充合适的HTML。
<strong>render</strong>方法约定总要返回<code>this</code>.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    render: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-159">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-159">&#182;</a>
              </div>
              <p>将视图的元素从DOM中移除，然后移除任何Backbone.Event的事件监听，这样便将View移除掉了。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    remove: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>._removeElement();
      <span class="hljs-keyword">this</span>.stopListening();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-160">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-160">&#182;</a>
              </div>
              <p>从文档中删除视图的元素以及所有添加到元素上的事件监听。子类可以使用其它的DOM操作的API。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _removeElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">this</span>.$el.remove();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-161">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-161">&#182;</a>
              </div>
              <p>更改视图的元素(<code>this.el</code>属性）并且在新元素上重新代理视图的事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    setElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">element</span>) </span>{
      <span class="hljs-keyword">this</span>.undelegateEvents();
      <span class="hljs-keyword">this</span>._setElement(element);
      <span class="hljs-keyword">this</span>.delegateEvents();
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-162">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-162">&#182;</a>
              </div>
              <p>使用给定的<code>el</code>在视图上创建 <code>this.el</code>和 <code>this.$el</code>引用。<code>el</code>属性可以是CSS选择器，或者是
一段HTML字符串，一个jQuery的上下文或一个DOM元素。子类可以覆盖此方法，来利用别的DOM操作的API来设置
<code>this.el</code>属性。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _setElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">el</span>) </span>{
      <span class="hljs-keyword">this</span>.$el = el <span class="hljs-keyword">instanceof</span> Backbone.$ ? el : Backbone.$(el);
      <span class="hljs-keyword">this</span>.el = <span class="hljs-keyword">this</span>.$el[<span class="hljs-number">0</span>];
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-163">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-163">&#182;</a>
              </div>
              <p>设置回调，<code>this.events</code>是一个形如以下类型的hash对。
   <em>{“event selector”: “callback”}</em>
    {
      ‘mousedown .title’:  ‘edit’,
      ‘click .button’:     ‘save’,
      ‘click .open’:       function(e) { … }
    }
回调函数会绑定在视图对象上，并且会正确的设置<code>this</code>引用。使用时间代理为的是效率。
请忽略掉用来绑定时间到<code>this.el</code>时使用的选择器。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    delegateEvents: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">events</span>) </span>{
      events || (events = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'events'</span>));
      <span class="hljs-keyword">if</span> (!events) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
      <span class="hljs-keyword">this</span>.undelegateEvents();
      <span class="hljs-keyword">for</span> (<span class="hljs-keyword">var</span> key <span class="hljs-keyword">in</span> events) {
        <span class="hljs-keyword">var</span> method = events[key];
        <span class="hljs-keyword">if</span> (!_.isFunction(method)) method = <span class="hljs-keyword">this</span>[method];
        <span class="hljs-keyword">if</span> (!method) <span class="hljs-keyword">continue</span>;
        <span class="hljs-keyword">var</span> match = key.match(delegateEventSplitter);
        <span class="hljs-keyword">this</span>.delegate(match[<span class="hljs-number">1</span>], match[<span class="hljs-number">2</span>], _.bind(method, <span class="hljs-keyword">this</span>));
      }
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-164">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-164">&#182;</a>
              </div>
              <p>添加单个事件监听到视图的DOM元素上（或者是使用<code>selector</code>指定的子元素上）。这只能在可代理的事件上工作：
<code>focus</code>，<code>blur</code>事件不行，IE下<code>change</code>, <code>submit</code>, 和 <code>reset</code>事件也不行。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    delegate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, selector, listener</span>) </span>{
      <span class="hljs-keyword">this</span>.$el.on(eventName + <span class="hljs-string">'.delegateEvents'</span> + <span class="hljs-keyword">this</span>.cid, selector, listener);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-165">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-165">&#182;</a>
              </div>
              <p>清除之前所有通过<code>delegateEvents</code>绑定到视图上的回调。你可能不需要使用本方法，但如果你有多个Backbone的
视图添加到了同一个DOM元素上，或许你会用到它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    undelegateEvents: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.$el) <span class="hljs-keyword">this</span>.$el.off(<span class="hljs-string">'.delegateEvents'</span> + <span class="hljs-keyword">this</span>.cid);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-166">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-166">&#182;</a>
              </div>
              <p>一个细粒度的<code>undelegateEvents</code>方法，用来移除单个代理事件。<code>selector</code> 和 <code>listener</code>都是可选的。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    undelegate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, selector, listener</span>) </span>{
      <span class="hljs-keyword">this</span>.$el.off(eventName + <span class="hljs-string">'.delegateEvents'</span> + <span class="hljs-keyword">this</span>.cid, selector, listener);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-167">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-167">&#182;</a>
              </div>
              <p>生成一个可以赋给视图的DOM元素。子类可以覆盖此方法，已使用别的DOM操作的API。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _createElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">tagName</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">document</span>.createElement(tagName);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-168">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-168">&#182;</a>
              </div>
              <p>保证视图有一个可渲染的DOM元素。如果<code>this.el</code>是一个字符串，它会被传入给<code>$()</code>，之后
拿到第一个匹配的元素，重新赋给<code>el</code>属性。否则，就根据 <code>id</code>, <code>className</code> 和 <code>tagName</code>属性创建一个新的元素。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _ensureElement: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.el) {
        <span class="hljs-keyword">var</span> attrs = _.extend({}, _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'attributes'</span>));
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.id) attrs.id = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'id'</span>);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.className) attrs[<span class="hljs-string">'class'</span>] = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'className'</span>);
        <span class="hljs-keyword">this</span>.setElement(<span class="hljs-keyword">this</span>._createElement(_.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'tagName'</span>)));
        <span class="hljs-keyword">this</span>._setAttributes(attrs);
      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">this</span>.setElement(_.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'el'</span>));
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-169">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-169">&#182;</a>
              </div>
              <p>将一个hash对象设置到视图元素的属性上。子类可以使用别的DOM操作的API覆盖本方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _setAttributes: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">attributes</span>) </span>{
      <span class="hljs-keyword">this</span>.$el.attr(attributes);
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-170">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-170">&#182;</a>
              </div>
              <h2 id="-backbone-sync">同步 - Backbone.sync</h2>

            </div>
            
        </li>
        
        
        <li id="section-171">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-171">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-172">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-172">&#182;</a>
              </div>
              <p>覆盖此方法，改变Backbone持久化数据到服务器的方式。你需要传入请求的类型，以及model。
默认，会向model的 <code>url()</code>指向的链接地址发送RESTful ajax请求。某些可能的环境下会：</p>
<ul>
<li>Use <code>setTimeout</code> to batch rapid-fire updates into a single request.</li>
<li>以XML格式而不是JSON格式发送模型。</li>
<li>通过WebSocket而不是Ajax持久化模型。</li>
</ul>
<p>开启<code>Backbone.emulateHTTP</code>，将<code>PUT</code>和<code>DELETE</code>以<code>POST</code>格式发送，使用<code>_method</code>
参数包含真正的HTTP方法，同时所有的请求体<code>model</code>为参数名称，以<code>application/x-www-form-urlencoded</code>格式而不是
<code>application/json</code>格式发送。在与像<strong>PHP</strong>这种服务器端交互时很有用，它在读取<code>PUT</code>请求体时比较困难。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.sync = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">method, model, options</span>) </span>{
    <span class="hljs-keyword">var</span> type = methodMap[method];</pre></div></div>
            
        </li>
        
        
        <li id="section-173">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-173">&#182;</a>
              </div>
              <p>没有指定选项，则使用默认选项。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _.defaults(options || (options = {}), {
      <span class="hljs-attr">emulateHTTP</span>: Backbone.emulateHTTP,
      <span class="hljs-attr">emulateJSON</span>: Backbone.emulateJSON
    });</pre></div></div>
            
        </li>
        
        
        <li id="section-174">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-174">&#182;</a>
              </div>
              <p>默认JSON请求的选项。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> params = {<span class="hljs-attr">type</span>: type, <span class="hljs-attr">dataType</span>: <span class="hljs-string">'json'</span>};</pre></div></div>
            
        </li>
        
        
        <li id="section-175">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-175">&#182;</a>
              </div>
              <p>保证我们有一个URL</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (!options.url) {
      params.url = _.result(model, <span class="hljs-string">'url'</span>) || urlError();
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-176">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-176">&#182;</a>
              </div>
              <p>保证我们有合适的请求数据。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (options.data == <span class="hljs-literal">null</span> &amp;&amp; model &amp;&amp; (method === <span class="hljs-string">'create'</span> || method === <span class="hljs-string">'update'</span> || method === <span class="hljs-string">'patch'</span>)) {
      params.contentType = <span class="hljs-string">'application/json'</span>;
      params.data = <span class="hljs-built_in">JSON</span>.stringify(options.attrs || model.toJSON(options));
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-177">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-177">&#182;</a>
              </div>
              <p>对于更老旧的服务器，通过将请求转义为一个HTML-form的格式来模拟JSON类型。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (options.emulateJSON) {
      params.contentType = <span class="hljs-string">'application/x-www-form-urlencoded'</span>;
      params.data = params.data ? {<span class="hljs-attr">model</span>: params.data} : {};
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-178">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-178">&#182;</a>
              </div>
              <p>对于老旧服务器，通过<code>_method</code>伪造一个HTTP方法来模拟HTTP请求。添加一个<code>X-HTTP-Method-Override</code>头。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (options.emulateHTTP &amp;&amp; (type === <span class="hljs-string">'PUT'</span> || type === <span class="hljs-string">'DELETE'</span> || type === <span class="hljs-string">'PATCH'</span>)) {
      params.type = <span class="hljs-string">'POST'</span>;
      <span class="hljs-keyword">if</span> (options.emulateJSON) params.data._method = type;
      <span class="hljs-keyword">var</span> beforeSend = options.beforeSend;
      options.beforeSend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr</span>) </span>{
        xhr.setRequestHeader(<span class="hljs-string">'X-HTTP-Method-Override'</span>, type);
        <span class="hljs-keyword">if</span> (beforeSend) <span class="hljs-keyword">return</span> beforeSend.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
      };
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-179">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-179">&#182;</a>
              </div>
              <p>在非GET请求下，不处理数据。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (params.type !== <span class="hljs-string">'GET'</span> &amp;&amp; !options.emulateJSON) {
      params.processData = <span class="hljs-literal">false</span>;
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-180">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-180">&#182;</a>
              </div>
              <p>在jQuery中回传<code>textStatus</code>和<code>errorThrown</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> error = options.error;
    options.error = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">xhr, textStatus, errorThrown</span>) </span>{
      options.textStatus = textStatus;
      options.errorThrown = errorThrown;
      <span class="hljs-keyword">if</span> (error) error.call(options.context, xhr, textStatus, errorThrown);
    };</pre></div></div>
            
        </li>
        
        
        <li id="section-181">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-181">&#182;</a>
              </div>
              <p>发送请求，允许用户覆盖任何Ajax的选项。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">var</span> xhr = options.xhr = Backbone.ajax(_.extend(params, options));
    model.trigger(<span class="hljs-string">'request'</span>, model, xhr, options);
    <span class="hljs-keyword">return</span> xhr;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-182">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-182">&#182;</a>
              </div>
              <p>CRUD操作到HTTP的映射，<code>Backbone.sync</code>默认的实现方式。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> methodMap = {
    <span class="hljs-string">'create'</span>: <span class="hljs-string">'POST'</span>,
    <span class="hljs-string">'update'</span>: <span class="hljs-string">'PUT'</span>,
    <span class="hljs-string">'patch'</span>: <span class="hljs-string">'PATCH'</span>,
    <span class="hljs-string">'delete'</span>: <span class="hljs-string">'DELETE'</span>,
    <span class="hljs-string">'read'</span>: <span class="hljs-string">'GET'</span>
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-183">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-183">&#182;</a>
              </div>
              <p>设置默认的<code>Backbone.ajax</code>实现，代理的是<code>$</code>。如果要用不同的库，请覆盖此方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.ajax = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">return</span> Backbone.$.ajax.apply(Backbone.$, <span class="hljs-built_in">arguments</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-184">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-184">&#182;</a>
              </div>
              <h2 id="-backbone-router">路由 - Backbone.Router</h2>

            </div>
            
        </li>
        
        
        <li id="section-185">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-185">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-186">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-186">&#182;</a>
              </div>
              <p>路由用来映射假的URL到action上，路由匹配时会触发事件。
创建一个新的路由，设置它的<code>routes</code>的hash。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> Router = Backbone.Router = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
    options || (options = {});
    <span class="hljs-keyword">if</span> (options.routes) <span class="hljs-keyword">this</span>.routes = options.routes;
    <span class="hljs-keyword">this</span>._bindRoutes();
    <span class="hljs-keyword">this</span>.initialize.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-187">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-187">&#182;</a>
              </div>
              <p>缓存的正则表达式，用来匹配路由字符串中具名参数部分和中间部分（splatted parts）。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> optionalParam = <span class="hljs-regexp">/\((.*?)\)/g</span>;
  <span class="hljs-keyword">var</span> namedParam    = <span class="hljs-regexp">/(\(\?)?:\w+/g</span>;
  <span class="hljs-keyword">var</span> splatParam    = <span class="hljs-regexp">/\*\w+/g</span>;
  <span class="hljs-keyword">var</span> escapeRegExp  = <span class="hljs-regexp">/[\-{}\[\]+?.,\\\^$|#\s]/g</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-188">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-188">&#182;</a>
              </div>
              <p>建立<strong>Backbone.Router</strong>所有可继承的属性和方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(Router.prototype, Events, {</pre></div></div>
            
        </li>
        
        
        <li id="section-189">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-189">&#182;</a>
              </div>
              <p>Initialize默认是个空函数。用你自己的初始化逻辑覆盖它。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    initialize: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{},</pre></div></div>
            
        </li>
        
        
        <li id="section-190">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-190">&#182;</a>
              </div>
              <p>手工绑定单个具名路由到回调上。比如：</p>
<pre><code><span class="hljs-keyword">this</span>.route(<span class="hljs-string">'search/:query/p:num'</span>, <span class="hljs-string">'search'</span>, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">query, num</span>) </span>{
  ...
});
</code></pre>
            </div>
            
            <div class="content"><div class='highlight'><pre>    route: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">route, name, callback</span>) </span>{
      <span class="hljs-keyword">if</span> (!_.isRegExp(route)) route = <span class="hljs-keyword">this</span>._routeToRegExp(route);
      <span class="hljs-keyword">if</span> (_.isFunction(name)) {
        callback = name;
        name = <span class="hljs-string">''</span>;
      }
      <span class="hljs-keyword">if</span> (!callback) callback = <span class="hljs-keyword">this</span>[name];
      <span class="hljs-keyword">var</span> router = <span class="hljs-keyword">this</span>;
      Backbone.history.route(route, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fragment</span>) </span>{
        <span class="hljs-keyword">var</span> args = router._extractParameters(route, fragment);
        <span class="hljs-keyword">if</span> (router.execute(callback, args, name) !== <span class="hljs-literal">false</span>) {
          router.trigger.apply(router, [<span class="hljs-string">'route:'</span> + name].concat(args));
          router.trigger(<span class="hljs-string">'route'</span>, name, args);
          Backbone.history.trigger(<span class="hljs-string">'route'</span>, router, name, args);
        }
      });
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-191">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-191">&#182;</a>
              </div>
              <p>提供给定参数，执行一个路由处理函数。这是一个路由触发前进行设置或路由触发后进行清空的绝佳场所。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    execute: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">callback, args, name</span>) </span>{
      <span class="hljs-keyword">if</span> (callback) callback.apply(<span class="hljs-keyword">this</span>, args);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-192">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-192">&#182;</a>
              </div>
              <p>只是简单的代理了<code>Backbone.history</code>，保存一个fragment到history中。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    navigate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fragment, options</span>) </span>{
      Backbone.history.navigate(fragment, options);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-193">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-193">&#182;</a>
              </div>
              <p>将所有定义的路由绑定到<code>Backbone.history</code>上。这里我们必须反转路由的次序，以支持
最笼统的路由应该定义在路由映射的最下方这一行为。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _bindRoutes: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.routes) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">this</span>.routes = _.result(<span class="hljs-keyword">this</span>, <span class="hljs-string">'routes'</span>);
      <span class="hljs-keyword">var</span> route, routes = _.keys(<span class="hljs-keyword">this</span>.routes);
      <span class="hljs-keyword">while</span> ((route = routes.pop()) != <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">this</span>.route(route, <span class="hljs-keyword">this</span>.routes[route]);
      }
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-194">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-194">&#182;</a>
              </div>
              <p>将一个路由字符串转换为一个正则表达式，适合用来匹配当前location的hash字符串。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _routeToRegExp: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">route</span>) </span>{
      route = route.replace(escapeRegExp, <span class="hljs-string">'\\$&amp;'</span>)
                   .replace(optionalParam, <span class="hljs-string">'(?:$1)?'</span>)
                   .replace(namedParam, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">match, optional</span>) </span>{
                     <span class="hljs-keyword">return</span> optional ? match : <span class="hljs-string">'([^/?]+)'</span>;
                   })
                   .replace(splatParam, <span class="hljs-string">'([^?]*?)'</span>);
      <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">RegExp</span>(<span class="hljs-string">'^'</span> + route + <span class="hljs-string">'(?:\\?([\\s\\S]*))?$'</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-195">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-195">&#182;</a>
              </div>
              <p>给定一个路由，和一个匹配的URL片段，返回提起并解码后的参数数组。空的或者未匹配的参数会
当做<code>null</code>来统一跨浏览器行为。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _extractParameters: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">route, fragment</span>) </span>{
      <span class="hljs-keyword">var</span> params = route.exec(fragment).slice(<span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> _.map(params, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">param, i</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-196">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-196">&#182;</a>
              </div>
              <p>不对搜索参数进行解码。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (i === params.length - <span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> param || <span class="hljs-literal">null</span>;
        <span class="hljs-keyword">return</span> param ? <span class="hljs-built_in">decodeURIComponent</span>(param) : <span class="hljs-literal">null</span>;
      });
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-197">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-197">&#182;</a>
              </div>
              <h2 id="-backbone-history">历史记录 - Backbone.History</h2>

            </div>
            
        </li>
        
        
        <li id="section-198">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-198">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-199">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-199">&#182;</a>
              </div>
              <p>处理跨浏览器历史管理，要么基于<a href="http://diveintohtml5.info/history.html">pushState</a>和真实的URLs，
要么基于<a href="https://developer.mozilla.org/en-US/docs/DOM/window.onhashchange">onhashchange</a>和URL片段。
如果浏览器都不支持二者（当然指的是老版本IE），则回滚值轮训方式。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> History = Backbone.History = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">this</span>.handlers = [];
    <span class="hljs-keyword">this</span>.checkUrl = _.bind(<span class="hljs-keyword">this</span>.checkUrl, <span class="hljs-keyword">this</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-200">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-200">&#182;</a>
              </div>
              <p>保证<code>History</code>可以在浏览器外使用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (<span class="hljs-keyword">typeof</span> <span class="hljs-built_in">window</span> !== <span class="hljs-string">'undefined'</span>) {
      <span class="hljs-keyword">this</span>.location = <span class="hljs-built_in">window</span>.location;
      <span class="hljs-keyword">this</span>.history = <span class="hljs-built_in">window</span>.history;
    }
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-201">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-201">&#182;</a>
              </div>
              <p>Cached regex for stripping a leading hash/slash and trailing space.
缓存的正则表达式用来移除起始位置的#，反斜杠或最后的空白符。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> routeStripper = <span class="hljs-regexp">/^[#\/]|\s+$/g</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-202">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-202">&#182;</a>
              </div>
              <p>缓存的正则表达式，用来删除起始或末尾的反斜杠。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> rootStripper = <span class="hljs-regexp">/^\/+|\/+$/g</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-203">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-203">&#182;</a>
              </div>
              <p>缓存的正则表达式URL的hash部分。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> pathStripper = <span class="hljs-regexp">/#.*$/</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-204">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-204">&#182;</a>
              </div>
              <p>标记history处理是否已经启动。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  History.started = <span class="hljs-literal">false</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-205">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-205">&#182;</a>
              </div>
              <p>建立<strong>Backbone.History</strong>所有可继承的属性和方法。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  _.extend(History.prototype, Events, {</pre></div></div>
            
        </li>
        
        
        <li id="section-206">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-206">&#182;</a>
              </div>
              <p>默认轮训检测hash辩护的间隔，如果有必要的话，一秒钟检测二十次。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    interval: <span class="hljs-number">50</span>,</pre></div></div>
            
        </li>
        
        
        <li id="section-207">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-207">&#182;</a>
              </div>
              <p>我们是否处在应用的根部？</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    atRoot: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> path = <span class="hljs-keyword">this</span>.location.pathname.replace(<span class="hljs-regexp">/[^\/]$/</span>, <span class="hljs-string">'$&amp;/'</span>);
      <span class="hljs-keyword">return</span> path === <span class="hljs-keyword">this</span>.root &amp;&amp; !<span class="hljs-keyword">this</span>.getSearch();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-208">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-208">&#182;</a>
              </div>
              <p>路径名是否匹配根路径名？</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    matchRoot: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> path = <span class="hljs-keyword">this</span>.decodeFragment(<span class="hljs-keyword">this</span>.location.pathname);
      <span class="hljs-keyword">var</span> rootPath = path.slice(<span class="hljs-number">0</span>, <span class="hljs-keyword">this</span>.root.length - <span class="hljs-number">1</span>) + <span class="hljs-string">'/'</span>;
      <span class="hljs-keyword">return</span> rootPath === <span class="hljs-keyword">this</span>.root;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-209">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-209">&#182;</a>
              </div>
              <p><code>location.pathname</code>中的Unicode字符是以编码后的形式存在的，所以比较前需要解码。<code>%25</code>不应该解码
因为它可能是一个编码参数的一部分。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    decodeFragment: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fragment</span>) </span>{
      <span class="hljs-keyword">return</span> <span class="hljs-built_in">decodeURI</span>(fragment.replace(<span class="hljs-regexp">/%25/g</span>, <span class="hljs-string">'%2525'</span>));
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-210">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-210">&#182;</a>
              </div>
              <p>在IE6下，如果hash的片段包含<code>?</code>，那么如果hash的片段和搜索参数是不正确的</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    getSearch: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> match = <span class="hljs-keyword">this</span>.location.href.replace(<span class="hljs-regexp">/#.*/</span>, <span class="hljs-string">''</span>).match(<span class="hljs-regexp">/\?.+/</span>);
      <span class="hljs-keyword">return</span> match ? match[<span class="hljs-number">0</span>] : <span class="hljs-string">''</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-211">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-211">&#182;</a>
              </div>
              <p>获取真正的hash值。Firefox的location.hash会是编码形式的，因为此bug我们不能直接使用location.hash。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    getHash: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">window</span>) </span>{
      <span class="hljs-keyword">var</span> match = (<span class="hljs-built_in">window</span> || <span class="hljs-keyword">this</span>).location.href.match(<span class="hljs-regexp">/#(.*)$/</span>);
      <span class="hljs-keyword">return</span> match ? match[<span class="hljs-number">1</span>] : <span class="hljs-string">''</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-212">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-212">&#182;</a>
              </div>
              <p>在不带根路径字符春的情况下，获取路径名和搜索参数。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    getPath: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
      <span class="hljs-keyword">var</span> path = <span class="hljs-keyword">this</span>.decodeFragment(
        <span class="hljs-keyword">this</span>.location.pathname + <span class="hljs-keyword">this</span>.getSearch()
      ).slice(<span class="hljs-keyword">this</span>.root.length - <span class="hljs-number">1</span>);
      <span class="hljs-keyword">return</span> path.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'/'</span> ? path.slice(<span class="hljs-number">1</span>) : path;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-213">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-213">&#182;</a>
              </div>
              <p>从path或hash中获取跨浏览器一直的URL片段。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    getFragment: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fragment</span>) </span>{
      <span class="hljs-keyword">if</span> (fragment == <span class="hljs-literal">null</span>) {
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._usePushState || !<span class="hljs-keyword">this</span>._wantsHashChange) {
          fragment = <span class="hljs-keyword">this</span>.getPath();
        } <span class="hljs-keyword">else</span> {
          fragment = <span class="hljs-keyword">this</span>.getHash();
        }
      }
      <span class="hljs-keyword">return</span> fragment.replace(routeStripper, <span class="hljs-string">''</span>);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-214">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-214">&#182;</a>
              </div>
              <p>开始处理hash的变更，如果当前的URL与已存在的一个路由匹配的话，返回<code>true</code>，否则返回<code>false</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    start: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">options</span>) </span>{
      <span class="hljs-keyword">if</span> (History.started) <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'Backbone.history has already been started'</span>);
      History.started = <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-215">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-215">&#182;</a>
              </div>
              <p>计算初始的配置。我们是否需要一个iframe？是否需要pushState… 它存在吗？</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.options          = _.extend({<span class="hljs-attr">root</span>: <span class="hljs-string">'/'</span>}, <span class="hljs-keyword">this</span>.options, options);
      <span class="hljs-keyword">this</span>.root             = <span class="hljs-keyword">this</span>.options.root;
      <span class="hljs-keyword">this</span>._wantsHashChange = <span class="hljs-keyword">this</span>.options.hashChange !== <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">this</span>._hasHashChange   = <span class="hljs-string">'onhashchange'</span> <span class="hljs-keyword">in</span> <span class="hljs-built_in">window</span> &amp;&amp; (<span class="hljs-built_in">document</span>.documentMode === <span class="hljs-keyword">void</span> <span class="hljs-number">0</span> || <span class="hljs-built_in">document</span>.documentMode &gt; <span class="hljs-number">7</span>);
      <span class="hljs-keyword">this</span>._useHashChange   = <span class="hljs-keyword">this</span>._wantsHashChange &amp;&amp; <span class="hljs-keyword">this</span>._hasHashChange;
      <span class="hljs-keyword">this</span>._wantsPushState  = !!<span class="hljs-keyword">this</span>.options.pushState;
      <span class="hljs-keyword">this</span>._hasPushState    = !!(<span class="hljs-keyword">this</span>.history &amp;&amp; <span class="hljs-keyword">this</span>.history.pushState);
      <span class="hljs-keyword">this</span>._usePushState    = <span class="hljs-keyword">this</span>._wantsPushState &amp;&amp; <span class="hljs-keyword">this</span>._hasPushState;
      <span class="hljs-keyword">this</span>.fragment         = <span class="hljs-keyword">this</span>.getFragment();</pre></div></div>
            
        </li>
        
        
        <li id="section-216">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-216">&#182;</a>
              </div>
              <p>一致化root，总在首位包含一个反斜杠。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">this</span>.root = (<span class="hljs-string">'/'</span> + <span class="hljs-keyword">this</span>.root + <span class="hljs-string">'/'</span>).replace(rootStripper, <span class="hljs-string">'/'</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-217">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-217">&#182;</a>
              </div>
              <p>从hashChange转换到pushState，如果同时都需要二者，反之亦然。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._wantsHashChange &amp;&amp; <span class="hljs-keyword">this</span>._wantsPushState) {</pre></div></div>
            
        </li>
        
        
        <li id="section-218">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-218">&#182;</a>
              </div>
              <p>如果我们从一个<code>pushState</code>开始，但现在浏览器不支持它…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._hasPushState &amp;&amp; !<span class="hljs-keyword">this</span>.atRoot()) {
          <span class="hljs-keyword">var</span> rootPath = <span class="hljs-keyword">this</span>.root.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>) || <span class="hljs-string">'/'</span>;
          <span class="hljs-keyword">this</span>.location.replace(rootPath + <span class="hljs-string">'#'</span> + <span class="hljs-keyword">this</span>.getPath());</pre></div></div>
            
        </li>
        
        
        <li id="section-219">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-219">&#182;</a>
              </div>
              <p>立即返回，因为浏览器会重定向到新的url上。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;</pre></div></div>
            
        </li>
        
        
        <li id="section-220">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-220">&#182;</a>
              </div>
              <p>或者，如果我们在基于hash的路由下开始，但我们当前在一个支持<code>pushState</code>…</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._hasPushState &amp;&amp; <span class="hljs-keyword">this</span>.atRoot()) {
          <span class="hljs-keyword">this</span>.navigate(<span class="hljs-keyword">this</span>.getHash(), {<span class="hljs-attr">replace</span>: <span class="hljs-literal">true</span>});
        }

      }</pre></div></div>
            
        </li>
        
        
        <li id="section-221">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-221">&#182;</a>
              </div>
              <p>如果浏览器不支持<code>hashchange</code>事件，HTML5的history，或用户希望<code>hashChange</code>而不是<code>pushState</code>，
就代理一个iframe来处理location事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>._hasHashChange &amp;&amp; <span class="hljs-keyword">this</span>._wantsHashChange &amp;&amp; !<span class="hljs-keyword">this</span>._usePushState) {
        <span class="hljs-keyword">this</span>.iframe = <span class="hljs-built_in">document</span>.createElement(<span class="hljs-string">'iframe'</span>);
        <span class="hljs-keyword">this</span>.iframe.src = <span class="hljs-string">'javascript:0'</span>;
        <span class="hljs-keyword">this</span>.iframe.style.display = <span class="hljs-string">'none'</span>;
        <span class="hljs-keyword">this</span>.iframe.tabIndex = <span class="hljs-number">-1</span>;
        <span class="hljs-keyword">var</span> body = <span class="hljs-built_in">document</span>.body;</pre></div></div>
            
        </li>
        
        
        <li id="section-222">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-222">&#182;</a>
              </div>
              <p>如果文档没有ready呢，使用<code>appendChild</code>在IE&lt;9下会抛出异常。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        <span class="hljs-keyword">var</span> iWindow = body.insertBefore(<span class="hljs-keyword">this</span>.iframe, body.firstChild).contentWindow;
        iWindow.document.open();
        iWindow.document.close();
        iWindow.location.hash = <span class="hljs-string">'#'</span> + <span class="hljs-keyword">this</span>.fragment;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-223">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-223">&#182;</a>
              </div>
              <p>为老旧版本的浏览器添加跨平台的<code>addEventListener</code>的shim。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> addEventListener = <span class="hljs-built_in">window</span>.addEventListener || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, listener</span>) </span>{
        <span class="hljs-keyword">return</span> attachEvent(<span class="hljs-string">'on'</span> + eventName, listener);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-224">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-224">&#182;</a>
              </div>
              <p>根据是否我们正使用pushState或hash，以及浏览器是否支持<code>onhashchange</code>，来决定我们检测URL状态的方式。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._usePushState) {
        addEventListener(<span class="hljs-string">'popstate'</span>, <span class="hljs-keyword">this</span>.checkUrl, <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._useHashChange &amp;&amp; !<span class="hljs-keyword">this</span>.iframe) {
        addEventListener(<span class="hljs-string">'hashchange'</span>, <span class="hljs-keyword">this</span>.checkUrl, <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._wantsHashChange) {
        <span class="hljs-keyword">this</span>._checkUrlInterval = setInterval(<span class="hljs-keyword">this</span>.checkUrl, <span class="hljs-keyword">this</span>.interval);
      }

      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.options.silent) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadUrl();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-225">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-225">&#182;</a>
              </div>
              <p>禁用 Backbone.history，可能是临时性的。在真实的应用中或许没用，但在路由的单元测试中可能有用。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    stop: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-226">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-226">&#182;</a>
              </div>
              <p>为老旧版本的浏览器添加跨平台的<code>removeEventListener</code>的shim。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> removeEventListener = <span class="hljs-built_in">window</span>.removeEventListener || <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">eventName, listener</span>) </span>{
        <span class="hljs-keyword">return</span> detachEvent(<span class="hljs-string">'on'</span> + eventName, listener);
      };</pre></div></div>
            
        </li>
        
        
        <li id="section-227">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-227">&#182;</a>
              </div>
              <p>移除window的监听器。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._usePushState) {
        removeEventListener(<span class="hljs-string">'popstate'</span>, <span class="hljs-keyword">this</span>.checkUrl, <span class="hljs-literal">false</span>);
      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._useHashChange &amp;&amp; !<span class="hljs-keyword">this</span>.iframe) {
        removeEventListener(<span class="hljs-string">'hashchange'</span>, <span class="hljs-keyword">this</span>.checkUrl, <span class="hljs-literal">false</span>);
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-228">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-228">&#182;</a>
              </div>
              <p>如果需要，清理iframe。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iframe) {
        <span class="hljs-built_in">document</span>.body.removeChild(<span class="hljs-keyword">this</span>.iframe);
        <span class="hljs-keyword">this</span>.iframe = <span class="hljs-literal">null</span>;
      }</pre></div></div>
            
        </li>
        
        
        <li id="section-229">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-229">&#182;</a>
              </div>
              <p>某些环境下在清除一个undefined的间隔时会抛出异常。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._checkUrlInterval) clearInterval(<span class="hljs-keyword">this</span>._checkUrlInterval);
      History.started = <span class="hljs-literal">false</span>;
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-230">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-230">&#182;</a>
              </div>
              <p>添加一个路由，在片段变更时会检测它。后添加的路由可能覆盖之前的路由。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    route: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">route, callback</span>) </span>{
      <span class="hljs-keyword">this</span>.handlers.unshift({<span class="hljs-attr">route</span>: route, <span class="hljs-attr">callback</span>: callback});
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-231">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-231">&#182;</a>
              </div>
              <p>查看当前的URL，检测它是否变化了，如果变化了，就调用<code>loadUrl</code>，通过隐藏的iframe一致化处理。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    checkUrl: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">e</span>) </span>{
      <span class="hljs-keyword">var</span> current = <span class="hljs-keyword">this</span>.getFragment();</pre></div></div>
            
        </li>
        
        
        <li id="section-232">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-232">&#182;</a>
              </div>
              <p>如果用户按了回退按钮，iframe的hash会变化，我们应该使用变化后的进行比较。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (current === <span class="hljs-keyword">this</span>.fragment &amp;&amp; <span class="hljs-keyword">this</span>.iframe) {
        current = <span class="hljs-keyword">this</span>.getHash(<span class="hljs-keyword">this</span>.iframe.contentWindow);
      }

      <span class="hljs-keyword">if</span> (current === <span class="hljs-keyword">this</span>.fragment) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iframe) <span class="hljs-keyword">this</span>.navigate(current);
      <span class="hljs-keyword">this</span>.loadUrl();
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-233">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-233">&#182;</a>
              </div>
              <p>尝试加载当前URL的片段。如果路由成功匹配了，返回<code>true</code>。如果定义的路由没有匹配的，返回<code>false</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    loadUrl: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fragment</span>) </span>{</pre></div></div>
            
        </li>
        
        
        <li id="section-234">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-234">&#182;</a>
              </div>
              <p>If the root doesn’t match, no routes can match either.</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (!<span class="hljs-keyword">this</span>.matchRoot()) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      fragment = <span class="hljs-keyword">this</span>.fragment = <span class="hljs-keyword">this</span>.getFragment(fragment);
      <span class="hljs-keyword">return</span> _.some(<span class="hljs-keyword">this</span>.handlers, <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">handler</span>) </span>{
        <span class="hljs-keyword">if</span> (handler.route.test(fragment)) {
          handler.callback(fragment);
          <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;
        }
      });
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-235">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-235">&#182;</a>
              </div>
              <p>将一个片段保存进hash历史中，或者如果传入<code>replace</code>选项就替换当前的URL状态。你需要负责提前进行正确的URL编码。</p>
<p>如果你希望触发路由的回调（通常不会），可以在选项对象包含<code>trigger: true</code>,或者如果你希望在不添加历史记录的前提下
修改当前的URL，就传入 <code>replace: true</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    navigate: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">fragment, options</span>) </span>{
      <span class="hljs-keyword">if</span> (!History.started) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;
      <span class="hljs-keyword">if</span> (!options || options === <span class="hljs-literal">true</span>) options = {<span class="hljs-attr">trigger</span>: !!options};</pre></div></div>
            
        </li>
        
        
        <li id="section-236">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-236">&#182;</a>
              </div>
              <p>一致化片段</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      fragment = <span class="hljs-keyword">this</span>.getFragment(fragment || <span class="hljs-string">''</span>);</pre></div></div>
            
        </li>
        
        
        <li id="section-237">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-237">&#182;</a>
              </div>
              <p>不要再root的尾部添加反斜杠。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">var</span> rootPath = <span class="hljs-keyword">this</span>.root;
      <span class="hljs-keyword">if</span> (fragment === <span class="hljs-string">''</span> || fragment.charAt(<span class="hljs-number">0</span>) === <span class="hljs-string">'?'</span>) {
        rootPath = rootPath.slice(<span class="hljs-number">0</span>, <span class="hljs-number">-1</span>) || <span class="hljs-string">'/'</span>;
      }
      <span class="hljs-keyword">var</span> url = rootPath + fragment;</pre></div></div>
            
        </li>
        
        
        <li id="section-238">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-238">&#182;</a>
              </div>
              <p>为匹配的路由删除hash符号并转码。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      fragment = <span class="hljs-keyword">this</span>.decodeFragment(fragment.replace(pathStripper, <span class="hljs-string">''</span>));

      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.fragment === fragment) <span class="hljs-keyword">return</span>;
      <span class="hljs-keyword">this</span>.fragment = fragment;</pre></div></div>
            
        </li>
        
        
        <li id="section-239">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-239">&#182;</a>
              </div>
              <p>如果pushState可用，我们使用它来设置片段为真正的URL。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._usePushState) {
        <span class="hljs-keyword">this</span>.history[options.replace ? <span class="hljs-string">'replaceState'</span> : <span class="hljs-string">'pushState'</span>]({}, <span class="hljs-built_in">document</span>.title, url);</pre></div></div>
            
        </li>
        
        
        <li id="section-240">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-240">&#182;</a>
              </div>
              <p>如果hash changes被显示的禁用了，就更新hash片段来存储记录。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      } <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>._wantsHashChange) {
        <span class="hljs-keyword">this</span>._updateHash(<span class="hljs-keyword">this</span>.location, fragment, options.replace);
        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span>.iframe &amp;&amp; fragment !== <span class="hljs-keyword">this</span>.getHash(<span class="hljs-keyword">this</span>.iframe.contentWindow)) {
          <span class="hljs-keyword">var</span> iWindow = <span class="hljs-keyword">this</span>.iframe.contentWindow;</pre></div></div>
            
        </li>
        
        
        <li id="section-241">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-241">&#182;</a>
              </div>
              <p>IE7及早期版本浏览器打开和关闭iframe的技巧，用以将hash变更push进历史中。当replace是true时，我们就不用这么干了。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>          <span class="hljs-keyword">if</span> (!options.replace) {
            iWindow.document.open();
            iWindow.document.close();
          }

          <span class="hljs-keyword">this</span>._updateHash(iWindow.location, fragment, options.replace);
        }</pre></div></div>
            
        </li>
        
        
        <li id="section-242">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-242">&#182;</a>
              </div>
              <p>如果你不需要基于hashchange的历史，那么<code>navigate</code>就变成了一次页面刷新。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>      } <span class="hljs-keyword">else</span> {
        <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.location.assign(url);
      }
      <span class="hljs-keyword">if</span> (options.trigger) <span class="hljs-keyword">return</span> <span class="hljs-keyword">this</span>.loadUrl(fragment);
    },</pre></div></div>
            
        </li>
        
        
        <li id="section-243">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-243">&#182;</a>
              </div>
              <p>更新hash地址，要么替换当前的记录，要么添加一个新的到浏览器历史中。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _updateHash: <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">location, fragment, replace</span>) </span>{
      <span class="hljs-keyword">if</span> (replace) {
        <span class="hljs-keyword">var</span> href = location.href.replace(<span class="hljs-regexp">/(javascript:|#).*$/</span>, <span class="hljs-string">''</span>);
        location.replace(href + <span class="hljs-string">'#'</span> + fragment);
      } <span class="hljs-keyword">else</span> {</pre></div></div>
            
        </li>
        
        
        <li id="section-244">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-244">&#182;</a>
              </div>
              <p>一些浏览器需要在<code>hash</code>的起始位置包含一个#。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>        location.hash = <span class="hljs-string">'#'</span> + fragment;
      }
    }

  });</pre></div></div>
            
        </li>
        
        
        <li id="section-245">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-245">&#182;</a>
              </div>
              <p>创建默认的Backbone.history对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Backbone.history = <span class="hljs-keyword">new</span> History;</pre></div></div>
            
        </li>
        
        
        <li id="section-246">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-246">&#182;</a>
              </div>
              <h2 id="-helpers">辅助工具 - Helpers</h2>

            </div>
            
        </li>
        
        
        <li id="section-247">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-247">&#182;</a>
              </div>
              
            </div>
            
        </li>
        
        
        <li id="section-248">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-248">&#182;</a>
              </div>
              <p>辅助函数，用来正确的设置子类的原型链。类似于<code>goog.inherits</code>，
但使用的是原型属性的hash和class属性的hash来进行继承。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> extend = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">protoProps, staticProps</span>) </span>{
    <span class="hljs-keyword">var</span> parent = <span class="hljs-keyword">this</span>;
    <span class="hljs-keyword">var</span> child;</pre></div></div>
            
        </li>
        
        
        <li id="section-249">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-249">&#182;</a>
              </div>
              <p>新的子类的构造器函数要么是你自己定义的（<code>extend</code>调用时传入的”constructor”属性），要么
就是有我们定义的类，它只简单的调用了父类的构造器。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    <span class="hljs-keyword">if</span> (protoProps &amp;&amp; _.has(protoProps, <span class="hljs-string">'constructor'</span>)) {
      child = protoProps.constructor;
    } <span class="hljs-keyword">else</span> {
      child = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>)</span>{ <span class="hljs-keyword">return</span> parent.apply(<span class="hljs-keyword">this</span>, <span class="hljs-built_in">arguments</span>); };
    }</pre></div></div>
            
        </li>
        
        
        <li id="section-250">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-250">&#182;</a>
              </div>
              <p>如果提供了静态属性，那么久添加到构造器函数上。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    _.extend(child, parent, staticProps);</pre></div></div>
            
        </li>
        
        
        <li id="section-251">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-251">&#182;</a>
              </div>
              <p>在不调用<code>parent</code>的构造器函数以及没有添加原型属性的情况下，设置原型链以继承<code>parent</code>。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    child.prototype = _.create(parent.prototype, protoProps);
    child.prototype.constructor = child;</pre></div></div>
            
        </li>
        
        
        <li id="section-252">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-252">&#182;</a>
              </div>
              <p>设置一个便捷的属性，以防自后需要使用父类的原型对象。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>    child.__super__ = parent.prototype;

    <span class="hljs-keyword">return</span> child;
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-253">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-253">&#182;</a>
              </div>
              <p>设置model，collection，router，view和history的继承性。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  Model.extend = Collection.extend = Router.extend = View.extend = History.extend = extend;</pre></div></div>
            
        </li>
        
        
        <li id="section-254">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-254">&#182;</a>
              </div>
              <p>在需要URL但又未提供时，抛出一个错误。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> urlError = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params"></span>) </span>{
    <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> <span class="hljs-built_in">Error</span>(<span class="hljs-string">'A "url" property or function must be specified'</span>);
  };</pre></div></div>
            
        </li>
        
        
        <li id="section-255">
            <div class="annotation">
              
              <div class="pilwrap ">
                <a class="pilcrow" href="#section-255">&#182;</a>
              </div>
              <p>封装一个可选的错误回调，触发一个error事件。</p>

            </div>
            
            <div class="content"><div class='highlight'><pre>  <span class="hljs-keyword">var</span> wrapError = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">model, options</span>) </span>{
    <span class="hljs-keyword">var</span> error = options.error;
    options.error = <span class="hljs-function"><span class="hljs-keyword">function</span>(<span class="hljs-params">resp</span>) </span>{
      <span class="hljs-keyword">if</span> (error) error.call(options.context, model, resp, options);
      model.trigger(<span class="hljs-string">'error'</span>, model, resp, options);
    };
  };

  <span class="hljs-keyword">return</span> Backbone;
});</pre></div></div>
            
        </li>
        
    </ul>
  </div>
</body>
</html>
